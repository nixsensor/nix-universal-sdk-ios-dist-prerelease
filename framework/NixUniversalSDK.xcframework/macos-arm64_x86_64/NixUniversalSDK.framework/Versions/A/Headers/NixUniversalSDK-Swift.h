#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef NIXUNIVERSALSDK_SWIFT_H
#define NIXUNIVERSALSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="NixUniversalSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

enum ReferenceWhite : uint16_t;
enum ScanMode : uint8_t;
enum ColorType : NSInteger;
enum ColorDifferenceType : NSInteger;

/// Protocol describing colorimetry data
SWIFT_PROTOCOL("_TtP15NixUniversalSDK10IColorData_")
@protocol IColorData
/// Color value (3 coordinates) in the format specified by <code>mode</code>.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
/// Reference white point for this color value.
@property (nonatomic, readonly) enum ReferenceWhite reference;
/// Scan mode for this value.
@property (nonatomic, readonly) enum ScanMode mode;
/// Type of color data stored in the <code>value</code> field.
@property (nonatomic, readonly) enum ColorType type;
/// sRGB value for this color.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull rgbValue;
/// Convert this color value to another <code>ColorType</code>.
- (id <IColorData> _Nonnull)convertToType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Calculate delta E between this color and another. The colors must share the same reference white point (<code>reference</code>).
/// \param other Another <code>IColorData</code> instance
///
/// \param type Delta E equation type (defaults to CIE2000)
///
- (double)compareToOther:(id <IColorData> _Nonnull)other type:(enum ColorDifferenceType)type SWIFT_WARN_UNUSED_RESULT;
@end


/// Class describing colorimetry data
SWIFT_CLASS("_TtC15NixUniversalSDK9ColorData")
@interface ColorData : NSObject <IColorData>
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
@property (nonatomic, readonly) enum ReferenceWhite reference;
@property (nonatomic, readonly) enum ScanMode mode;
@property (nonatomic, readonly) enum ColorType type;
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull rgbValue;
- (id <IColorData> _Nonnull)convertToType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
- (double)compareToOther:(id <IColorData> _Nonnull)other type:(enum ColorDifferenceType)type SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum describing the available color difference (delta E) equations.
typedef SWIFT_ENUM(NSInteger, ColorDifferenceType, open) {
/// Color difference using CIE1976 equation.
  ColorDifferenceTypeCIE76 = 0,
/// Color difference using CIE1994 equation using constants recommended for graphic design.
  ColorDifferenceTypeCIE94G = 1,
/// Color difference using CIE1994 equation using constants recommended for textiles.
  ColorDifferenceTypeCIE94T = 2,
/// Color difference using CIE2000 equation using default constants.
  ColorDifferenceTypeCIE2000 = 3,
/// Color difference using CMC(l:c) equation with l = 1, and c = 1 (‘threshold of imperceptibility’)
  ColorDifferenceTypeCMC1_1 = 4,
/// Color difference using CMC(l:c) equation with l = 2, and c = 1 (‘threshold of acceptability’)
  ColorDifferenceTypeCMC2_1 = 5,
};

/// Enum to describe the base color data types available for <code>IColorData</code> objects. Values for each of these types can be freely converted to each other without loss of color data.
typedef SWIFT_ENUM(NSInteger, ColorType, open) {
/// Report color value as CIEXYZ value on unity scale.
  ColorTypeCIEXYZ = 0,
/// Report color value as CIELAB value.
  ColorTypeCIELAB = 1,
/// Report color value as CIELCH / LCH(ab) value
  ColorTypeCIELCH = 2,
/// Report color as CIELUV value
  ColorTypeCIELUV = 3,
};

enum Illuminant : uint8_t;
enum Observer : uint8_t;
enum DensityStatus : NSInteger;

/// Color math utility functions
SWIFT_CLASS("_TtC15NixUniversalSDK10ColorUtils")
@interface ColorUtils : NSObject
/// Takes CIEXYZ value and its reference white to calculate CIELAB value. <code>xyz</code> and <code>xyzRef</code> can be either unity (0 - 1) or scaled (0 - 100) input, but both vectors must be the same scale; if <code>xyz</code> is unity scale, <code>xyzRef</code> must also be unity scale
/// \param xyz CIEXYZ value (element order X, Y, Z)
///
/// \param xyzRef reference white (element order X, Y, Z)
///
///
/// returns:
/// CIELAB value (element order L, a, b)
+ (NSArray<NSNumber *> * _Nonnull)xyzToLabWithXyz:(NSArray<NSNumber *> * _Nonnull)xyz xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Clips CIEXYZ values in between 0 and the value of the reference white to ensure X,Y,Z are in the proper range.
/// \param xyz CIEXYZ value for color (X, Y, Z)
///
/// \param xyzRef CIEXYZ value for reference white (X, Y, Z)
///
///
/// returns:
/// CIEXYZ value (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)clipXyzWithXyz:(NSArray<NSNumber *> * _Nonnull)xyz xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELAB value and its reference white to calculate CIEXYZ value
/// \param lab CIELAB value (element order L, a, b)
///
/// \param xyzRef Reference white (element order X, Y, Z)
///
///
/// returns:
/// CIEXYZ value (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)labToXyzWithLab:(NSArray<NSNumber *> * _Nonnull)lab xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1976 formula. Both CIELAB values must share the same reference white. If they do not, convert to XYZ, adapt, convert back to CIELAB before calculating dE
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE1976) value
+ (double)deltaE76WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1994 formula. Requires weighting factors kL, k1, and k2 which are dependent on application. Use the <code>deltaE94G</code> method for graphic design applications and the <code>deltaE94T</code> for textile applications. Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
/// \param kL Weighting factor (application dependent)
///
/// \param k1 Weighting factor (application dependent)
///
/// \param k2 Weighting factor (application dependent)
///
///
/// returns:
/// dE (CIE1994) value
+ (double)deltaE94WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 kL:(double)kL k1:(double)k1 k2:(double)k2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1994 formula for the graphic design application (<code>kL</code> = 1, <code>k1</code> = 0.045, <code>k2</code> = 0.015). Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE1994) value
+ (double)deltaE94GWithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1994 formula for the textiles application (<code>kL</code> = 2, <code>k1</code> = 0.048, <code>k2</code> = 0.014). Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE1994) value
+ (double)deltaE94TWithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE2000 formula using default model parameters (kL = kC = kH = 1.0). Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE2000) value
+ (double)deltaE00WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE2000 formula. Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
/// \param kL Model parameter (default 1)
///
/// \param kC Model parameter (default 1)
///
/// \param kH Model parameter (default 1)
///
///
/// returns:
/// dE (CIE2000) value
+ (double)deltaE00WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 kL:(double)kL kC:(double)kC kH:(double)kH SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CMC(l:c) formula. Depends on model parameters l and c; common values used are CMC(2:1) for acceptability and CMC(1:1) for perceptibility. Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
/// \param l model parameter l
///
/// \param c model parameter c
///
///
/// returns:
/// dE (CMC) value
+ (double)deltaECmcWithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 l:(double)l c:(double)c SWIFT_WARN_UNUSED_RESULT;
/// Adapts colour in XYZ from one reference white to another using Bradford adaptation method. NOTE: <code>refIn</code>, <code>refOut</code>, <code>xyzIn</code> must all be on the same scale.
/// \param xyzIn Source color, referenced to <code>refIn</code> (element order X, Y, Z)
///
/// \param refIn Source reference white (element order X, Y, Z)
///
/// \param refOut Destination reference white (element order X, Y, Z)
///
///
/// returns:
/// Adapted color, referenced to <code>refOut</code> (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)adaptXyzWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn refIn:(NSArray<NSNumber *> * _Nonnull)refIn refOut:(NSArray<NSNumber *> * _Nonnull)refOut SWIFT_WARN_UNUSED_RESULT;
/// Calculates linear RGB from XYZ given chromaticity coordinates of RGB working space primaries and reference whites of RGB and XYZ value
/// \param xyzIn Input colour XYZ values, unity scale (element order X, Y, Z)
///
/// \param refIn Reference white of input colour <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
/// \param rChrom RGB space red primary chromaticity coordinates (element order x, y)
///
/// \param gChrom RGB space green primary chromaticity coordinates (element order x, y)
///
/// \param bChrom RGB space blue primary chromaticity coordinates (element order x, y)
///
/// \param wChrom RGB space reference white/grey chromaticity coordinates (element order x, y)
///
///
/// returns:
/// Linear RGB value, unity scale, (element order R, G, B)
+ (NSArray<NSNumber *> * _Nonnull)xyzToRgbWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn refIn:(NSArray<NSNumber *> * _Nonnull)refIn rChrom:(NSArray<NSNumber *> * _Nonnull)rChrom gChrom:(NSArray<NSNumber *> * _Nonnull)gChrom bChrom:(NSArray<NSNumber *> * _Nonnull)bChrom wChrom:(NSArray<NSNumber *> * _Nonnull)wChrom SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ from linear RGB given chromaticity coordinates of RGB working space primaries and reference whites of RGB and XYZ value.
/// \param rgbIn Input linear RGB value, unity scale (element order R, G, B)
///
/// \param rChrom RGB space red primary chromaticity coordinates (element order x, y)
///
/// \param gChrom RGB space green primary chromaticity coordinates (element order x, y)
///
/// \param bChrom RGB space blue primary chromaticity coordinates (element order x, y)
///
/// \param wChrom RGB space reference white/grey chromaticity coordinates (element order x, y)
///
/// \param refOut Selected reference white of output XYZ color, unity scale (element order X, Y, Z)
///
///
/// returns:
/// XYZ value, unity scale, with reference white <code>refOut</code> (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)rgbToXyzWithRgbIn:(NSArray<NSNumber *> * _Nonnull)rgbIn rChrom:(NSArray<NSNumber *> * _Nonnull)rChrom gChrom:(NSArray<NSNumber *> * _Nonnull)gChrom bChrom:(NSArray<NSNumber *> * _Nonnull)bChrom wChrom:(NSArray<NSNumber *> * _Nonnull)wChrom refOut:(NSArray<NSNumber *> * _Nonnull)refOut SWIFT_WARN_UNUSED_RESULT;
/// Calculates companded sRGB value from XYZ given reference white of XYZ value
/// \param xyzIn Input colour XYZ values, unity scale (element order X, Y, Z)
///
/// \param refIn Reference white of input colour <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
///
/// returns:
/// Non-linear sRGB value, 0-255 scale (element order R, G, B)
+ (NSArray<NSNumber *> * _Nonnull)xyzToSrgbWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn refIn:(NSArray<NSNumber *> * _Nonnull)refIn SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ from sRGB value.
/// \param sRgb Non-linear sRGB value, 0-255 scale (element order R, G, B)
///
/// \param refOut Selected reference white of output XYZ color, unity scale (element order X, Y, Z)
///
///
/// returns:
/// XYZ value, unity scale, with reference white <code>refOut</code> (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)sRgbToXyzWithSRgb:(NSArray<NSNumber *> * _Nonnull)sRgb refOut:(NSArray<NSNumber *> * _Nonnull)refOut SWIFT_WARN_UNUSED_RESULT;
/// Takes CIEXYZ value and its reference white to calculate CIELUV value
/// \param xyzIn CIEXYZ value (element order X, Y, Z)
///
/// \param xyzRef CIEXYZ reference white (element order X, Y, Z)
///
///
/// returns:
/// CIELUV value (element order L, u, v)
+ (NSArray<NSNumber *> * _Nonnull)xyzToLuvWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELUV value and its reference white to calculate CIEXYZ value
/// \param luvIn CIELUV value (element order L, u, v)
///
/// \param xyzRef CIEXYZ reference white (element order X, Y, Z)
///
///
/// returns:
/// CIEXYZ value (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)luvToXyzWithLuvIn:(NSArray<NSNumber *> * _Nonnull)luvIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELAB value and converts to polar coordinates (LCH)
/// \param labIn CIELAB value (element order L, a, b)
///
///
/// returns:
/// LCHab value (element order L, c, h). Hue angle h is in degrees
+ (NSArray<NSNumber *> * _Nonnull)labToLchWithLabIn:(NSArray<NSNumber *> * _Nonnull)labIn SWIFT_WARN_UNUSED_RESULT;
/// Takes LCHab value and converts to CIELAB
/// \param lchIn LCHab value (element order L, c, h). Hue angle h is in degrees
///
///
/// returns:
/// CIELAB value (element order L, a, b)
+ (NSArray<NSNumber *> * _Nonnull)lchToLabWithLchIn:(NSArray<NSNumber *> * _Nonnull)lchIn SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELUV value and converts to polar coordinates (LCH)
/// \param luvIn CIELUV value (element order L, u, v)
///
///
/// returns:
/// LCHuv value (element order L, c, h). Hue angle h is in degrees
+ (NSArray<NSNumber *> * _Nonnull)luvToLchWithLuvIn:(NSArray<NSNumber *> * _Nonnull)luvIn SWIFT_WARN_UNUSED_RESULT;
/// Takes LCHuv value and converts to CIELUV
/// \param lchIn LCHuv value (element order L, c, h). Hue angle h is in degrees
///
///
/// returns:
/// CIELUV value (element order L, u, v)
+ (NSArray<NSNumber *> * _Nonnull)lchToLuvWithLchIn:(NSArray<NSNumber *> * _Nonnull)lchIn SWIFT_WARN_UNUSED_RESULT;
/// Takes reflectance data on 10 nm intervals and calculates a CIEXYZ value according to ASTM E308. Data must be provided on 10 nm intervals corresponding to the nearest 10 nanometer. CIEXYZ values are calculated across the range 360 - 780 nm. If the provided data spans a shorter range (eg - 400 - 700 nm), the values at the boundaries are repeated.
/// \param lambda Wavelength values of provided reflectance data.
///
/// \param reflectance Reflectance data. Must contain the same number of elements as <code>lambda</code>
///
/// \param illuminant Selected illuminant
///
/// \param observer Selected observer
///
///
/// returns:
/// CIEXYZ value reported on 0 - 1.0 scale (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)spectral10ToXyzWithLambda:(NSArray<NSNumber *> * _Nonnull)lambda reflectance:(NSArray<NSNumber *> * _Nonnull)reflectance illuminant:(enum Illuminant)illuminant observer:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Takes reflectance data on 10 nm intervals and calculates CMYK densities according to ISO 5-3:2009. Data must be provided on 10 nm intervals corresponding to the nearest 10 nanometer. Density values are calculated across the range 340 - 770 nm. If the provided data spans a shorter range (eg - 400 - 700 nm), the values at the boundaries are repeated.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
/// \param lambda Wavelength values of provided reflectance data.
///
/// \param reflectance Reflectance data. Must contain the same number of elements as <code>lambda</code>
///
/// \param status Selected density status
///
///
/// returns:
/// CMYK densities (element order C, M, Y, K)
+ (NSArray<NSNumber *> * _Nonnull)spectral10ToDensityWithLambda:(NSArray<NSNumber *> * _Nonnull)lambda reflectance:(NSArray<NSNumber *> * _Nonnull)reflectance status:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
/// Calculates CMYK value from XYZ input using built in lookup tables
/// \param xyzIn XYZ colour, unity scale (element order X, Y, Z)
///
/// \param xyzRef Reference white value for <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
///
/// returns:
/// CMYK value on unity scale (element order C, M, Y, K)
+ (NSArray<NSNumber *> * _Nonnull)xyzToCmykWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef bpc:(BOOL)bpc SWIFT_WARN_UNUSED_RESULT;
/// Calculates CMYK value from XYZ using lookup tables provided as <code>inputCurves</code> arguments
/// \param xyzIn XYZ colour, unity scale (element order X, Y, Z)
///
/// \param xyzRef Reference white value for <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
/// \param m 3x3 matrix extracted from ICC profile: transformation matrix to perform on LAB value (code only tested with identity matrix)
///
/// \param inputCurves 256x3 matrix extracted from ICC profile: <code>InputCurves</code>
///
/// \param clut Extracted from ICC profile: Lab to CMYK LUT (flattened 33x33x33 array with 4 channels, one each for C,M,Y,K)
///
/// \param outputCurves 256x4 matrix extracted from ICC profile: <code>OutputCurves</code>
///
///
/// returns:
/// CMYK value on unity scale (element order C, M, Y, K)
+ (NSArray<NSNumber *> * _Nonnull)xyzToCmykWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef bpc:(BOOL)bpc m:(NSArray<NSArray<NSNumber *> *> * _Nonnull)m inputCurves:(NSArray<NSArray<NSNumber *> *> * _Nonnull)inputCurves clut:(NSArray<NSArray<NSNumber *> *> * _Nonnull)clut outputCurves:(NSArray<NSArray<NSNumber *> *> * _Nonnull)outputCurves SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ value from CMYK input using built-in lookup tables
/// \param cmykIn CMYK colour input, unity scale (element order C, M, Y, K)
///
/// \param refOut Reference white value for XYZ output, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
///
/// returns:
/// XYZ value output, unity scale (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)cmykToXyzWithCmykIn:(NSArray<NSNumber *> * _Nonnull)cmykIn refOut:(NSArray<NSNumber *> * _Nonnull)refOut bpc:(BOOL)bpc SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ value from CMYK input using lookup tables provided as input arguments
/// \param cmykIn CMYK colour input, unity scale (element order C, M, Y, K)
///
/// \param refOut Reference white value for XYZ output, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
/// \param m 3x3 Extracted from ICC profile: transformation matrix to perform on LAB value (NOT used in current function)
///
/// \param input 256x4 matrix extracted from ICC profile: <code>InputCurves</code>
///
/// \param clut 6561x3 matrix extracted from ICC profile: CMYK to LAB LUT (flattened 9x9x9x9 array with 3 channels, one each for L, A, B)
///
/// \param output Extracted from ICC profile: <code>OutputCurves</code> (NOT used in current function, default profile has 1:1 output)
///
///
/// returns:
/// XYZ value output, unity scale (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)cmykToXyzWithCmykIn:(NSArray<NSNumber *> * _Nonnull)cmykIn refOut:(NSArray<NSNumber *> * _Nonnull)refOut bpc:(BOOL)bpc m:(NSArray<NSArray<NSNumber *> *> * _Nonnull)m input:(NSArray<NSArray<NSNumber *> *> * _Nonnull)input clut:(NSArray<NSArray<NSNumber *> *> * _Nonnull)clut output:(NSArray<NSArray<NSNumber *> *> * _Nonnull)output SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Enum describing the possible status of commands executed by the Nix device, as provided in the <code>DeviceResultCallback</code>.
typedef SWIFT_ENUM(NSInteger, CommandStatus, open) {
/// Status code indicating that the command completed successfully.
  CommandStatusSUCCESS = 0,
/// Status code indicating that the command was aborted because the Nix device was not ready (i.e. - it was already executing another command).
  CommandStatusERROR_NOT_READY = 1,
/// Status code indicating that the command was aborted because the it was not supported by the Nix device instance.
  CommandStatusERROR_NOT_SUPPORTED = 2,
/// Status code indicating that the command was aborted because it contained invalid arguments.
  CommandStatusERROR_INVALID_ARGUMENT = 3,
/// Status code indicating that the command was aborted because of a low power state on the Nix device (e.g. - insufficient battery power to complete a measurement).
  CommandStatusERROR_LOW_POWER = 4,
/// Status code indicating that the command failed due to a timeout error.
  CommandStatusERROR_TIMEOUT = 5,
/// Status code indicating that the measurement operation failed due to the detection of ambient light leakage.
  CommandStatusERROR_AMBIENT_LIGHT = 6,
/// Status code indicating that the in-field calibration operation failed due to high delta E (i.e. - the calibration reference tile could not be verified by its color value). This status is only possible after a <code>IDeviceCompat/runFieldCalibration(tileString:completion:)</code> command.
  CommandStatusERROR_SCAN_DELTA = 7,
/// Status code indicating that the command failed due to an unknown / internal SDK error.
  CommandStatusERROR_INTERNAL = 8,
/// Status code indicating that the in-field calibration operation completed successfully, but a temperature warning was issued (i.e. - the ambient temperature of the device is currently outside of the recommended range). This status is only possible after a <code>IDeviceCompat/runFieldCalibration(tileString:completion:)</code> command.
  CommandStatusWARNING_TEMPERATURE = 9,
/// Status code indicating that the command failed due to a problem with the <code>LicenseManager</code>. Check <code>LicenseManager/state</code> for details.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
  CommandStatusERROR_LICENSE = 10,
};

@class NSString;

/// Protocol describing density data
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
SWIFT_PROTOCOL("_TtP15NixUniversalSDK12IDensityData_")
@protocol IDensityData
/// Density values (4 channels, CMYK order)
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
/// Indicates which channel (0 - 3) in <code>value</code> has the strongest response, with greyness override
@property (nonatomic, readonly) NSInteger autoIndex;
/// Density status for this value
@property (nonatomic, readonly) enum DensityStatus status;
/// Density status label for this value (eg - ‘T’ for <code>DensityStatus/T</code>)
@property (nonatomic, readonly, copy) NSString * _Nonnull statusLabel;
/// Scan mode for this measurement.
@property (nonatomic, readonly) enum ScanMode mode;
@end


/// Class describing density data
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15NixUniversalSDK11DensityData")
@interface DensityData : NSObject <IDensityData>
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
@property (nonatomic, readonly) NSInteger autoIndex;
@property (nonatomic, readonly) enum DensityStatus status;
@property (nonatomic, readonly, copy) NSString * _Nonnull statusLabel;
@property (nonatomic, readonly) enum ScanMode mode;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum to describe the available options for density status
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, DensityStatus, open) {
/// Status A (ISO 5-3:2009)
  DensityStatusA = 1,
/// Status E (ISO 5-3:2009)
  DensityStatusE = 2,
/// Status I (ISO 5-3:2009)
  DensityStatusI = 3,
/// Status T (ISO 5-3:2009)
  DensityStatusT = 4,
/// Unknown / undefined conditions
  DensityStatusNONE = 0,
};

enum DeviceScannerState : NSInteger;
@protocol IDeviceCompat;

/// Protocol implemented by the <code>DeviceScanner</code>
SWIFT_PROTOCOL("_TtP15NixUniversalSDK14IDeviceScanner_")
@protocol IDeviceScanner
/// Current state of the <code>IDeviceScanner</code>
@property (nonatomic, readonly) enum DeviceScannerState state;
/// Starts a search for nearby Nix devices using Bluetooth for time interval of <code>DeviceScanner/DEFAULT_GENERAL_SCAN_PERIOD_MS</code>.
/// <ul>
///   <li>
///     See also: <code>start(scanPeriodMs:closure:)</code>
///   </li>
/// </ul>
/// \param closure Closure invoked when a device is found. Invoked with a <code>nil</code> result when a search times out and device was not found.
///
- (enum DeviceScannerState)startWithClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Starts a search for nearby Nix devices using Bluetooth for a selected time interval. If no timeout interval is specified, the search will run for <code>DeviceScanner/DEFAULT_GENERAL_SCAN_PERIOD_MS</code>.
/// <ul>
///   <li>
///     See also: <code>start(closure:)</code>
///   </li>
/// </ul>
/// \param scanPeriodMs Period to run the search in milliseconds.
///
/// \param closure Closure invoked when a device is found. Invoked with a <code>nil</code> result when a search times out and device was not found.
///
- (enum DeviceScannerState)startForPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Starts a search for a specific Nix device using Bluetooth. The search will run until the specified device is found, or until <code>DeviceScanner/DEFAULT_SINGLE_DEVICE_PERIOD_MS</code> elapses, whichever is shorter. Invoked with a <code>nil</code> result when a search times out and device was not found.
/// <ul>
///   <li>
///     See also: <code>startSearchForId(_:scanPeriodMs:closure:)</code>
///   </li>
/// </ul>
/// \param id Nix device ID used to filter search results
///
/// \param closure Closure invoked when a device is found.
///
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Starts a search for a specific Nix device using Bluetooth. The search will run until the specified device is found, or until a timeout elapses, whichever is shorter. If no timeout interval is specified, the search will run for <code>DeviceScanner/DEFAULT_SINGLE_DEVICE_PERIOD_MS</code>.
/// <ul>
///   <li>
///     See also: <code>startSearchForId(_:closure:)</code>
///   </li>
/// </ul>
/// \param id Nix device ID used to filter search results
///
/// \param scanPeriodMs Max time period to run the search, in milliseconds
///
/// \param closure Closure invoked when a device is found. Invoked with a <code>nil</code> result when a search times out and device was not found.
///
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id forPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Stops a Bluetooth search if one is currently running.
- (void)stop;
@end

@protocol ScannerStateDelegate;

/// Class used to discover nearby Nix devices
SWIFT_CLASS("_TtC15NixUniversalSDK13DeviceScanner")
@interface DeviceScanner : NSObject <IDeviceScanner>
- (nonnull instancetype)initWithDelegate:(id <ScannerStateDelegate> _Nonnull)delegate OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) enum DeviceScannerState state;
- (enum DeviceScannerState)startWithClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (enum DeviceScannerState)startForPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id forPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (void)stop;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum describing the possible states of the <code>IDeviceScanner</code>
typedef SWIFT_ENUM(NSInteger, DeviceScannerState, open) {
/// Bluetooth scanner is not actively searching for devices.
  DeviceScannerStateIDLE = 0,
/// Bluetooth scanner is actively searching for devices.
  DeviceScannerStateSCANNING = 1,
/// Bluetooth scanner could not start because Bluetooth permissions have not been granted.
  DeviceScannerStateERROR_BLUETOOTH_PERMISSIONS = 2,
/// Bluetooth scanner could not start because Bluetooth is disabled on this mobile device.
  DeviceScannerStateERROR_BLUETOOTH_DISABLED = 3,
/// Bluetooth scanner could not start because Bluetooth is not available on this mobile device.
  DeviceScannerStateERROR_BLUETOOTH_UNAVAILABLE = 4,
/// Bluetooth scanner could not start because an invalid hardware ID was provided.
  DeviceScannerStateERROR_INVALID_HARDWARE_ID = 5,
/// Bluetooth scanner could not start due to an internal error.
  DeviceScannerStateERROR_INTERNAL = 6,
/// Bluetooth scanner could not start due to a problem with the <code>LicenseManager</code>. Check <code>LicenseManager/state</code> for details.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
  DeviceScannerStateERROR_LICENSE = 7,
/// Bluetooth scanner state is cold / unknown (scanner is initializing)
  DeviceScannerStateCOLD = -1,
};

/// Enum describing the possible states of the <code>IDeviceCompat</code>
typedef SWIFT_ENUM(NSInteger, DeviceState, open) {
/// The device is disconnected.
  DeviceStateDISCONNECTED = 0,
/// The device is busy establishing a connection with the host device.
  DeviceStateBUSY_CONNECTING = 1,
/// The device is busy; a connection has been opened but services are being discovered.
  DeviceStateBUSY_DISCOVERING = 2,
/// The device is busy; a connection has been opened but characteristic notification / subscriptions are pending.
  DeviceStateBUSY_SUBSCRIBING = 3,
/// The device is busy with a data transfer to the host device.
  DeviceStateBUSY_DATA_TRANSFER = 4,
/// The device is busy executing a command.
  DeviceStateBUSY_RUNNING_COMMAND = 5,
/// The device is idle and ready to receive commands. This is the only state where commands can be successfully executed.
  DeviceStateIDLE = 6,
};

enum DeviceStatus : NSInteger;
@class NSNumber;

/// Definition for a callback from an <code>IDeviceCompat</code> instance on a connection state change, battery state change, or external power state change.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK19DeviceStateDelegate_")
@protocol DeviceStateDelegate
/// Called when the Nix device has completed the connection process and is now idle.
/// \param sender Device instance that invoked this call
///
- (void)onConnected:(id <IDeviceCompat> _Nonnull)sender;
/// Called when the Nix device has disconnected from the host.
/// \param sender Device instance that invoked this call
///
/// \param status Status code indicating the reason for the disconnection
///
- (void)onDisconnected:(id <IDeviceCompat> _Nonnull)sender status:(enum DeviceStatus)status;
/// Called when the Nix device has updated its battery level measurement.
/// \param sender Device instance that has invoked this call
///
/// \param newState New battery level (0 to 100)
///
- (void)onBatteryStateChanged:(id <IDeviceCompat> _Nonnull)sender newState:(NSNumber * _Nonnull)newState;
/// Called when the Nix device has been connected or disconnected from an external power source.
/// \param sender Device instance that has invoked this call
///
/// \param newState New external power connection state
///
- (void)onExtPowerStateChanged:(id <IDeviceCompat> _Nonnull)sender newState:(BOOL)newState;
@end

/// Enum describing the possible causes of a device disconnection event in the <code>DeviceStateDelegate</code>.
typedef SWIFT_ENUM(NSInteger, DeviceStatus, open) {
/// The device has disconnected normally (e.g. - via calling <code>IDeviceCompat/disconnect()</code>).
  DeviceStatusSUCCESS = 0,
/// The device connection attempt was cancelled because the maximum number of attempts was reached.
  DeviceStatusERROR_MAX_ATTEMPTS = 1,
/// The device connection attempt was cancelled due to a timeout error.
  DeviceStatusERROR_TIMEOUT = 2,
/// The device connection attempt was cancelled because the specified device type was not supported.
  DeviceStatusERROR_UNSUPPORTED_DEVICE = 3,
/// The device has disconnected unexpectedly (possibly due to low Bluetooth signal strength or low battery level).
  DeviceStatusERROR_DROPPED_CONNECTION = 4,
/// The device connection attempt was cancelled because the specified device was not authorized for this build of the Nix SDK. Check that the device allocation code and/or serial number is expected to be authorized for this build.
  DeviceStatusERROR_UNAUTHORIZED = 5,
/// The device has disconnected for an unknown reason (internal SDK error).
  DeviceStatusERROR_INTERNAL = 6,
/// The device disconnected due to a problem with the <code>LicenseManager</code>. Check that the license is active via <code>LicenseManager/state</code> and that the device type is supported via <code>LicenseManager/isDeviceTypeSupported(_:)</code>.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
  DeviceStatusERROR_LICENSE = 7,
};

/// Enum to describe the supported Nix device types
typedef SWIFT_ENUM(uint8_t, DeviceType, open) {
/// Type for Nix Mini colorimeter
  DeviceTypeMINI = 0x00,
/// Type for Nix Mini 2 colorimeter
  DeviceTypeMINI2 = 0x01,
/// Type for Nix Pro colorimeter
  DeviceTypePRO = 0x02,
/// Type for Nix Pro 2 colorimeter
  DeviceTypePRO2 = 0x03,
/// Type for Nix QC colorimeter
  DeviceTypeQC = 0x04,
/// Type for Nix Spectro 2 spectrophotometer
  DeviceTypeSPECTRO2 = 0x05,
/// Type for Nix Mini 3 colorimeter
  DeviceTypeMINI3 = 0x06,
/// Type for Nix Spectro L spectrophometer
/// <ul>
///   <li>
///     Since 4.1.0
///   </li>
/// </ul>
  DeviceTypeSPECTROL = 0x07,
/// Unknown / other device type
  DeviceTypeUNKNOWN = 0xFF,
};


/// Class to describe Nix device revisions
SWIFT_CLASS("_TtC15NixUniversalSDK13DeviceVersion")
@interface DeviceVersion : NSObject
/// String value for this version
@property (nonatomic, readonly, copy) NSString * _Nonnull string;
/// Single character prefix for this version. Expected values are ‘F’ for  firmware version, ‘H’ for hardware version, ‘S’ for software version.
@property (nonatomic, readonly, copy) NSString * _Nonnull prefix;
/// Major revision number
@property (nonatomic, readonly) NSInteger major;
/// Minor revision number
@property (nonatomic, readonly) NSInteger minor;
/// Patch revision number
@property (nonatomic, readonly) NSInteger patch;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



enum InterfaceType : NSInteger;
@class NSDate;
@protocol IMeasurementData;

/// Protocol describing the supported properties and methods for a Nix device. <code>IDeviceCompat</code> objects are found nearby using the <code>DeviceScanner</code>.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK13IDeviceCompat_")
@protocol IDeviceCompat
/// Unique identifier for this device
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// Signal strength for this device
@property (nonatomic) NSInteger rssi;
/// Current state of this device
@property (nonatomic, readonly) enum DeviceState state;
/// Type for this device
@property (nonatomic, readonly) enum DeviceType type;
/// Interface / connection type for this device
@property (nonatomic, readonly) enum InterfaceType interfaceType;
/// Name for this device
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// Factory note for this device, containing allocation code. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, copy) NSString * _Nonnull note;
/// Serial number for this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, copy) NSString * _Nonnull serialNumber;
/// Firmware version of this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) DeviceVersion * _Nonnull firmwareVersion;
/// Hardware version of this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) DeviceVersion * _Nonnull hardwareVersion;
/// Software version of this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) DeviceVersion * _Nonnull softwareVersion;
/// Current battery level for this device (0 - 100), or <code>nil</code> if not available. <code>NSNumber</code> contains an integer value. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) NSNumber * _Nullable batteryLevel;
/// Flag: <code>true</code> if sufficient power is available to complete a measurement, <code>false</code> if a measurement will be aborted (function of external power connection and battery level)
@property (nonatomic, readonly) BOOL powerState;
/// External power connection state for this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly) BOOL extPowerState;
/// Last known temperature of the device, corresponding to the most recently completed scan since the device was connected. <code>NSNumber</code> contains a <code>Float</code> value. Value is <code>nil</code> if the device does not support this feature. This value is only valid if the device is connected and a measurement has completed.
@property (nonatomic, readonly, strong) NSNumber * _Nullable scanTemperature;
/// Baseline temperature for this device. Corresponds to in-field normalization temperature for <code>DeviceType/SPECTRO2</code> and <code>DeviceType/MINI3</code>, or factory temperature for others. <code>NSNumber</code> contains a <code>Float</code> value. Value is <code>nil</code> if the device does not support this feature. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) NSNumber * _Nullable referenceTemperature;
/// Date that the last in-field normalization was last performed, or <code>nil</code> if this device does not support this feature.
@property (nonatomic, readonly, copy) NSDate * _Nullable referenceDate;
/// Lifetime scan count for this device, or <code>nil</code> if this device does not support this feature. <code>NSNumber</code> contains an <code>Int</code> value.
@property (nonatomic, readonly, strong) NSNumber * _Nullable scanCount;
/// UUID for this <code>NixUniversalSDK</code> license
/// <ul>
///   <li>
///     See also <code>LicenseManager/uuid</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nonnull sdkId;
/// Open a connection to this Nix device. This operation is asynchronous and this method returns immediately. Status of this operation is updated via the provided <code>DeviceStateDelegate</code> callback.
/// \param delegate Delegate through which device state changes are provided.
///
- (void)connect:(id <DeviceStateDelegate> _Nonnull)delegate;
/// Disconnect from this Nix device, or cancel a connection attempt currently in progress.
- (void)disconnect;
/// Manually run a LED test routine. On devices featuring RGB feedback, this will use the RGB LEDs. On other devices, this will flash the white LEDs. This method is asynchronous and will return immediately.
/// \param completion Closure which will provide command status on completion.
///
- (void)ledTest:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Run a measurement for all supported scan modes. This method is asynchronous and will return immediately.
/// <ul>
///   <li>
///     See also: <code>measure(modes:completion:)-18cni</code>
///   </li>
///   <li>
///     See also (Swift only): <code>measure(modes:completion:)-71wc2</code>
///   </li>
/// </ul>
/// \param completion Closure which will provide command status on completion.
///
- (void)measure:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Run a measurement in the specified scan modes. If any unsupported modes are selected, the measurement will fail with status code <code>CommandStatus/ERROR_NOT_SUPPORTED</code>. This method is asynchronous and will return immediately.
/// <ul>
///   <li>
///     See also: <code>measure(completion:)</code>
///   </li>
/// </ul>
/// \param modes Scan modes to select. Set must contain <code>NSNumber</code> values matching <code>ScanMode</code> enum values
///
/// \param completion Closure which will provide command status on completion.
///
- (void)measureWithModes:(NSSet<NSNumber *> * _Nonnull)modes completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Start field calibration using provided reference tile, if supported. Upon executing this command, the scan of the reference tile will begin immediately. The user MUST be prompted to place the device onto the reference tile BEFORE this method is executed. This method is asynchronous and will return immediately.
/// This command requires data from the reference tile QR code. As the format varies between different device types, the string data should be provided exactly as decoded from the QR code.
/// \param tileString String value decoded from the reference tile QR code.
///
/// \param completion Closure which will provide command status on completion.
///
- (void)runFieldCalibration:(NSString * _Nonnull)tileString completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Invalidates current field calibration date, so that <code>fieldCalibrationDue</code> is reported as <code>true</code>, if supported by the device.
/// \param completion Closure which will provide command status on completion.
///
- (void)invalidateFieldCalibrationWithCompletion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Check if the formatting of the reference tile string data matches the expected format for this device, or <code>false</code> if the device does not support this feature.
/// \param tileString String value decoded from the reference tile QR code.
///
- (BOOL)isTileStringValid:(NSString * _Nonnull)tileString SWIFT_WARN_UNUSED_RESULT;
/// List of scan modes that are supported by this device (set of <code>NSNumber</code> containing <code>ScanMode</code> values). The list is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, copy) NSSet<NSNumber *> * _Nonnull supportedModes;
/// Helper to check if a particular scan mode is supported by this device (i.e. - checks if the mode is present in the <code>supportedModes</code> list). This value is valid only after a connection has successfully been opened.
- (BOOL)isModeSupported:(enum ScanMode)scanMode SWIFT_WARN_UNUSED_RESULT;
/// Flag to indicate if this device type provides spectral information in its supplied <code>IMeasurementData</code> results.
@property (nonatomic, readonly) BOOL providesSpectral;
/// Flag to indicate if this device type provides density information in its supplied <code>IMeasurementData</code> results.
@property (nonatomic, readonly) BOOL providesDensity;
/// List of supported reference white points for the colorimetry data available from the <code>IMeasurementData</code> results provided by this device (set of <code>NSNumber</code> containing <code>ReferenceWhite</code> values)
@property (nonatomic, readonly, copy) NSSet<NSNumber *> * _Nonnull supportedReferences;
/// Helper to check if a particular reference white point is supported by the colorimetry data from this device (i.e - checks if the reference is present in the <code>supportedReferences</code> list`).
- (BOOL)providesColorWithReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Helper to check if a particular reference white point is supported by the colorimetry data from this device (i.e - checks if the reference is present in the <code>supportedReferences</code> list`).
- (BOOL)providesColorForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Helper function to describe if any on-device options are available. Value is <code>true</code> if any one of <code>supportsFieldCalibration</code>, <code>supportsTemperatureCompensation</code>, <code>supportsHapticFeedback</code>, or <code>supportsRgbFeedback</code> is <code>true</code>.
@property (nonatomic, readonly) BOOL hasOptions;
/// Flag to indicate if this device supports in-field calibration using the provided reference tile.
@property (nonatomic, readonly) BOOL supportsFieldCalibration;
/// Flag to indicate if in-field calibration is recommended for this device at this time (if supported). This value is only valid after opening a connection and is a function of both time and ambient temperature. This value also updates each time a measurement is completed.
@property (nonatomic, readonly) BOOL fieldCalibrationDue;
/// Maximum Delta E threshold used when performing in-field calibration (if supported), or NaN if the device does not support this operation. If a difference from the reference greater than this value is detected during <code>runFieldCalibration(tileString:completion:)</code>, the command will fail with status <code>CommandStatus/ERROR_SCAN_DELTA</code>.
@property (nonatomic) double fieldCalibrationMaxDelta;
/// Flag to indicate if in-field calibration results are applied (<code>true</code>) or bypassed (<code>false</code>) when evaluating the final calibrated measurement result. Value is <code>true</code> by default if supported by the device. It is recommended to leave this set to <code>true</code> if supported.
@property (nonatomic, readonly) BOOL fieldCalibrationEnabled;
/// Set the value for <code>fieldCalibrationEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setFieldCalibrationEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Flag to indicate if this device supports automatic temperature compensation to correct for small changes in ambient temperature.
@property (nonatomic, readonly) BOOL supportsTemperatureCompensation;
/// Flag to indicate if ambient temperature compensation / correction is applied (<code>true</code>) or bypassed (<code>false</code>) when evaluating the final calibrated measurement. Value is <code>true</code> by default if supported by the device. It is recommended to leave this set to <code>true</code> if supported.
@property (nonatomic, readonly) BOOL temperatureCompensationEnabled;
/// Set the value for <code>temperatureCompensationEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setTemperatureCompensationEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Flag to indicate if the device supports built-in haptic feedback.
@property (nonatomic, readonly) BOOL supportsHapticFeedback;
/// Flag to indicate if device haptic feedback is enabled.
@property (nonatomic, readonly) BOOL hapticFeedbackEnabled;
/// Set the value for <code>hapticFeedbackEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setHapticFeedbackEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Flag to indicate if the device supports built-in RGB feedback.
@property (nonatomic, readonly) BOOL supportsRgbFeedback;
/// Flag to indicate if device RGB feedback is enabled.
@property (nonatomic, readonly) BOOL rgbFeedbackEnabled;
/// Set the value for <code>rgbFeedbackEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setRgbFeedbackEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
@end


@protocol ISpectralData;

/// Protocol defining the properties and methods provided by Nix device measurements. These objects are provided in the <code>DeviceResultCallback</code> callback after a measurement is taken using an <code>IDeviceCompat</code> instance, or can be reconstructed from raw string data using <code>MeasurementData/fromRaw(_:)</code>.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK16IMeasurementData_")
@protocol IMeasurementData
/// Raw data for a measurement. Can be used for measurement object reconstruction.
@property (nonatomic, readonly, copy) NSString * _Nonnull raw;
/// Scan status byte. A value of <code>0x01</code> indicates success, all other values indicate error states. <code>UInt8</code> value wrapped in <code>NSNumber</code>
@property (nonatomic, readonly, strong) NSNumber * _Nonnull status;
/// Device type that was used to make this measurement.
@property (nonatomic, readonly) enum DeviceType deviceType;
/// Scan mode for this measurement.
@property (nonatomic, readonly) enum ScanMode mode;
/// Baseline reference temperature for this measurement, or <code>nil</code> if the device did not support temperature measurements. Optional <code>Float</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tRef;
/// Temperature of the Nix device at the time of this measurement, or <code>nil</code> if the device did not support temperature measurements. Optional <code>Float</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tScan;
/// Flag indicating if temperature compensation was applied to the calibrated output for this measurement. Value is <code>nil</code> if the device did not support temperature measurements. Optional <code>Bool</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tCompEnabled;
/// Flag describing the units for the reported temperature measurement. When <code>true</code>, temperature values are ‘real’ (floating point, degrees C). When <code>false</code>, temperatures are reported on an arbitrary raw scale. Value is <code>nil</code> if the device did not support temperature measurements. Optional <code>Bool</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tReal;
/// Flag indicating if in-field profiling corrections / white reference tile measurements were applied to the calibrated output data. Value is <code>nil</code> if the device did not support in-field profiling. Optional <code>Bool</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tileEnabled;
/// Delta E value between this measurement and factory reference. Value is non-nil for measurement values from <code>IDeviceCompat/runFieldCalibration(tileString:completion:)</code> and <code>nil</code> in all other cases.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tileDelta;
/// Flag (as a <code>NSNumber</code> wrapped <code>Bool</code>) indicating if this measurement provides spectral values. This value depends on both the <code>deviceType</code> and availability of the <code>LicenseFeature/SPECTRAL_DATA</code> feature.
/// <ul>
///   <li>
///     See also: <code>DeviceType/isFeatureSupported(_:)</code>
///   </li>
///   <li>
///     See also: <code>LicenseManager/isFeatureEnabled(_:)</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, strong) NSNumber * _Nonnull providesSpectral;
/// Provides a spectral data object from this measurement, or <code>nil</code> if spectral data is not supported.
@property (nonatomic, readonly, strong) id <ISpectralData> _Nullable spectralData;
/// Flag (as a <code>NSNumber</code> wrapped <code>Bool</code>) indicating if this measurement provides density values. This value depends on both the <code>deviceType</code> and availability of the <code>LicenseFeature/DENSITY_DATA</code> feature.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
@property (nonatomic, readonly, strong) NSNumber * _Nonnull providesDensity;
/// Provides absolute density values for this measurement evaluated as per ISO 5-3:2009, or <code>nil</code> if density data is not supported.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
/// \param status Density status (defaults to <code>DensityStatus/T</code>)
///
- (id <IDensityData> _Nullable)toDensityDataForStatus:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
/// Array describing all reference white points that are available when requesting color data from this measurement using <code>toColorData(reference:type:)</code>.
@property (nonatomic, readonly, copy) NSSet<NSNumber *> * _Nonnull supportedReferences;
/// Returns <code>true</code> if color data for the selected combination of illuminant and observer are available for this measurement.
- (BOOL)providesColorForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if color data for the selected combination of illuminant and observer are available for this measurement.
- (BOOL)providesColorForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if color data for the selected combination of illuminant and observer are available for this measurement.
- (BOOL)providedColorForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Use providesColor(illuminant:observer:) instead");
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toColorData(illuminant:observer:type:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForReference:(enum ReferenceWhite)reference andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toColorData(reference:type:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also <code>toRgbValue(illuminant:observer:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also <code>toRgbValue(reference:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
@end


/// Protocol describing spectral data obtained from a measurement
SWIFT_PROTOCOL("_TtP15NixUniversalSDK13ISpectralData_")
@protocol ISpectralData
/// Wavelength values. Each entry <code>i</code> in this array corresponds to a spectral value in <code>value</code> at the same index.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull lambda;
/// Wavelength spacing (eg - 10 nm)
@property (nonatomic, readonly) NSInteger interval;
/// Spectral reflectance values. Each entry <code>i</code> in this array corresponds to a wavelength value in <code>lambda</code> at the same index.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
/// Scan mode for this measurement.
@property (nonatomic, readonly) enum ScanMode mode;
/// Provides absolute density values for this measurement for the specified density status evaluated as per ISO 5-3:2009.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
/// \param status Density status (defaults to <code>DensityStatus/T</code>)
///
- (id <IDensityData> _Nullable)toDensityDataForStatus:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if an invalid white point is specified.
/// <ul>
///   <li>
///     See also: <code>toColorData(illuminant:observer:type:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForReference:(enum ReferenceWhite)reference andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if an invalid white point is specified.
/// <ul>
///   <li>
///     See also: <code>toColorData(reference:type:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toRgbValue(illuminant:observer:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toRgbValue(reference:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Provides an interpolated reflectance value at a specified wavelength value using natural cubic spines. The cubic splines are evaluated at the points specified by <code>lambda</code> and <code>value</code>. Interpolated values are evaluated using natural cubic splines.
/// \param lT Wavelength (nm) at which to query the interpolated reflectance
///
///
/// returns:
/// interpolated reflectance value at lT
- (float)interpolateAtLt:(float)lT SWIFT_WARN_UNUSED_RESULT;
@end

/// Enum to describe the available options for reference illuminant
typedef SWIFT_ENUM(uint8_t, Illuminant, open) {
  IlluminantA = 0x01,
  IlluminantC = 0x02,
  IlluminantD50 = 0x03,
  IlluminantD55 = 0x04,
  IlluminantD65 = 0x05,
  IlluminantD75 = 0x06,
  IlluminantF2 = 0x07,
  IlluminantF7 = 0x08,
  IlluminantF11 = 0x09,
  IlluminantNONE = 0x00,
};

/// Enum describing the supported connection interface types for Nix devices.
typedef SWIFT_ENUM(NSInteger, InterfaceType, open) {
/// Device does not have a defined connection type.
  InterfaceTypeUNDEFINED = 0,
/// Device connects via Bluetooth (BLE) interface.
  InterfaceTypeBLE = 1,
/// Device connects via USB interface.
  InterfaceTypeUSB_CDC = 2,
};

/// Enum describing the optional features that can be enabled by the <code>LicenseManager</code>. Feature availability can be queried using <code>LicenseManager/isFeatureEnabled(_:)</code>.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, LicenseFeature, open) {
/// Provides access to basic device information and colorimetry values via <code>IColorData</code> for all Nix devices.
  LicenseFeatureBASIC_DATA = 0,
/// Provides access to density values via <code>IDensityData</code>, if supported by the Nix device.
  LicenseFeatureDENSITY_DATA = 1,
/// Provides access to spectral values via <code>ISpectralData</code>, if supported by the Nix device.
  LicenseFeatureSPECTRAL_DATA = 2,
};

enum LicenseManagerState : NSInteger;

/// Class used to manage the license for the Nix Universal SDK. Members of this class are not instantiated or accessed directly. Access to a single shared instance is provided via static methods and properties.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15NixUniversalSDK14LicenseManager")
@interface LicenseManager : NSObject
/// Describes the current state of the  <code>LicenseManager</code>. Nix Universal SDK functions are available only if license is active (i.e. - the state is <code>LicenseManagerState/ACTIVE</code>)
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) enum LicenseManagerState state;)
+ (enum LicenseManagerState)state SWIFT_WARN_UNUSED_RESULT;
/// List of Nix device allocation codes associated with the current license.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<NSString *> * _Nonnull allocations;)
+ (NSArray<NSString *> * _Nonnull)allocations SWIFT_WARN_UNUSED_RESULT;
/// Set of <code>NSNumber</code> containing the <code>DeviceType</code> values enabled by the current license.
/// <ul>
///   <li>
///     See also <code>allowedDeviceTypes-4f98s</code> for convenience in Swift
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<NSNumber *> * _Nonnull allowedDeviceTypes;)
+ (NSSet<NSNumber *> * _Nonnull)allowedDeviceTypes SWIFT_WARN_UNUSED_RESULT;
/// Expiry date for the current license.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSDate * _Nonnull expiry;)
+ (NSDate * _Nonnull)expiry SWIFT_WARN_UNUSED_RESULT;
/// Set of <code>NSNumber</code> containing the <code>LicenseFeature</code> values enabled by the current license.
/// <ul>
///   <li>
///     See also: <code>features-3nk3h</code> for convenience in Swift
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<NSNumber *> * _Nonnull features;)
+ (NSSet<NSNumber *> * _Nonnull)features SWIFT_WARN_UNUSED_RESULT;
/// Vendor identifier for the current license.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull uuid;)
+ (NSString * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
/// Current version of the Nix Universal SDK.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull libraryVersion;)
+ (NSString * _Nonnull)libraryVersion SWIFT_WARN_UNUSED_RESULT;
/// Helper to check if a particular <code>DeviceType</code> is supported by the current license.
+ (BOOL)isDeviceTypeSupported:(enum DeviceType)type SWIFT_WARN_UNUSED_RESULT;
/// Helper to check if a particular <code>LicenseFeature</code> is enabled by the current license.
+ (BOOL)isFeatureEnabled:(enum LicenseFeature)feature SWIFT_WARN_UNUSED_RESULT;
/// Activates a license. The options and signature parameters must exactly match the values provided in the SDK license. Calling this function invalidates any currently active license.
/// \param options License options
///
/// \param signature License signature, used to validate the license options.
///
///
/// returns:
/// License manager state after activation
+ (enum LicenseManagerState)activateWithOptions:(NSString * _Nonnull)options andSignature:(NSString * _Nonnull)signature;
/// Deactivates the current license.
+ (void)deactivate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum describing the possible states of the <code>LicenseManager</code>.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, LicenseManagerState, open) {
/// The license has not been activated yet. Activate the license using <code>LicenseManager/activate(options:signature:)</code>.
  LicenseManagerStateINACTIVE = 0,
/// The license has activated successfully and Nix Universal SDK functions are available.
  LicenseManagerStateACTIVE = 1,
/// The license has failed to activate because the signature was invalid. Verify that the correct  options and signature were used when calling <code>LicenseManager/activate(options:signature:)</code>. Contact the Nix SDK support team if this error persists.
  LicenseManagerStateERROR_LICENSE_BAD_SIGNATURE = 2,
/// The license failed to activate because the options string was invalid. Contact the Nix SDK support team.
  LicenseManagerStateERROR_LICENSE_INVALID_OPTIONS = 3,
/// The license has expired and is no longer valid. Contact the Nix SDK support team.
  LicenseManagerStateERROR_LICENSE_EXPIRED = 4,
/// An unknown error occurred when activating the license. Contact the Nix SDK support team.
  LicenseManagerStateERROR_INTERNAL = -1,
};


/// Class describing measurement data from a Nix device
SWIFT_CLASS("_TtC15NixUniversalSDK15MeasurementData")
@interface MeasurementData : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Enum to describe the available options for reference observer
typedef SWIFT_ENUM(uint8_t, Observer, open) {
/// Observer defined by CIE1931 (2 degree)
  ObserverCIE1931 = 0x01,
/// Observer defined by CIE1964 (10 degree)
  ObserverCIE1964 = 0x04,
  ObserverNONE = 0x00,
};

/// Enum to describe valid options for reference white IDs
typedef SWIFT_ENUM(uint16_t, ReferenceWhite, open) {
/// White point using Illuminant A and 2 degree observer.
  ReferenceWhiteA_2 = 0x0000,
/// White point using Illuminant A and 10 degree observer.
  ReferenceWhiteA_10 = 0x0001,
/// White point using Illuminant C and 2 degree observer.
  ReferenceWhiteC_2 = 0x0002,
/// White point using Illuminant C and 10 degree observer.
  ReferenceWhiteC_10 = 0x0003,
/// White point using Illuminant D50 and 2 degree observer.
  ReferenceWhiteD50_2 = 0x0004,
/// White point using Illuminant D50 and 10 degree observer.
  ReferenceWhiteD50_10 = 0x0005,
/// White point using Illuminant D55 and 2 degree observer.
  ReferenceWhiteD55_2 = 0x0006,
/// White point using Illuminant D55 and 10 degree observer.
  ReferenceWhiteD55_10 = 0x0007,
/// White point using Illuminant D65 and 2 degree observer.
  ReferenceWhiteD65_2 = 0x0008,
/// White point using Illuminant D65 and 10 degree observer.
  ReferenceWhiteD65_10 = 0x0009,
/// White point using Illuminant D75 and 2 degree observer.
  ReferenceWhiteD75_2 = 0x000A,
/// White point using Illuminant D75 and 10 degree observer.
  ReferenceWhiteD75_10 = 0x000B,
/// White point using Illuminant F2 and 2 degree observer.
  ReferenceWhiteF2_2 = 0x000C,
/// White point using Illuminant F2 and 10 degree observer.
  ReferenceWhiteF2_10 = 0x000D,
/// White point using Illuminant F7 and 2 degree observer.
  ReferenceWhiteF7_2 = 0x000E,
/// White point using Illuminant F7 and 10 degree observer.
  ReferenceWhiteF7_10 = 0x000F,
/// White point using Illuminant F11 and 2 degree observer.
  ReferenceWhiteF11_2 = 0x0010,
/// White point using Illuminant F11 and 10 degree observer.
  ReferenceWhiteF11_10 = 0x0011,
/// Unknown / other reference white point
  ReferenceWhiteEMPTY = 0xFFFF,
};

/// Enum to describe the measurement modes used by Nix devices
typedef SWIFT_ENUM(uint8_t, ScanMode, open) {
/// M0 conditions (ISO 13655)
  ScanModeM0 = 0x00,
/// M1 conditions (ISO 13655)
  ScanModeM1 = 0x01,
/// M2 conditions (ISO 13655)
  ScanModeM2 = 0x02,
/// Unknown / undefined conditions
  ScanModeNA = 0xFF,
};


/// Protocol definition for a callback to be invoked when an <code>IDeviceScanner</code> starts or stops a search.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK20ScannerStateDelegate_")
@protocol ScannerStateDelegate
/// Called when the <code>IDeviceScanner</code> has initialized. Check <code>state</code> to determine success or failure code.
/// \param sender <code>IDeviceScanner</code> instance that invoked this call
///
/// \param state Current state of the <code>IDeviceScanner</code>
///
- (void)onScannerInit:(id <IDeviceScanner> _Nonnull)sender state:(enum DeviceScannerState)state;
/// Called when an <code>IDeviceScanner</code> has started searching
/// \param sender <code>IDeviceScanner</code> instance that invoked this call
///
- (void)onScannerStarted:(id <IDeviceScanner> _Nonnull)sender;
/// Called when an <code>IDeviceScanner</code> has stopped searching
/// \param sender <code>IDeviceScanner</code> instance that invoked this call
///
- (void)onScannerStopped:(id <IDeviceScanner> _Nonnull)sender;
@end


/// Class describing spectral data
SWIFT_CLASS("_TtC15NixUniversalSDK12SpectralData")
@interface SpectralData : NSObject <ISpectralData>
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull lambda;
@property (nonatomic, readonly) NSInteger interval;
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
@property (nonatomic, readonly) enum ScanMode mode;
- (id <IDensityData> _Nullable)toDensityDataForStatus:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
- (id <IColorData> _Nullable)toColorDataForReference:(enum ReferenceWhite)reference andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
- (id <IColorData> _Nullable)toColorDataForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nullable)toRgbValueForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nullable)toRgbValueForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
- (float)interpolateAtLt:(float)lT SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef NIXUNIVERSALSDK_SWIFT_H
#define NIXUNIVERSALSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="NixUniversalSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

enum ReferenceWhite : uint16_t;
enum ScanMode : uint8_t;
enum ColorType : NSInteger;
enum ColorDifferenceType : NSInteger;

/// Protocol describing colorimetry data
SWIFT_PROTOCOL("_TtP15NixUniversalSDK10IColorData_")
@protocol IColorData
/// Color value (3 coordinates) in the format specified by <code>mode</code>.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
/// Reference white point for this color value.
@property (nonatomic, readonly) enum ReferenceWhite reference;
/// Scan mode for this value.
@property (nonatomic, readonly) enum ScanMode mode;
/// Type of color data stored in the <code>value</code> field.
@property (nonatomic, readonly) enum ColorType type;
/// sRGB value for this color.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull rgbValue;
/// Convert this color value to another <code>ColorType</code>.
- (id <IColorData> _Nonnull)convertToType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Calculate delta E between this color and another. The colors must share the same reference white point (<code>reference</code>).
/// \param other Another <code>IColorData</code> instance
///
/// \param type Delta E equation type (defaults to CIE2000)
///
- (double)compareToOther:(id <IColorData> _Nonnull)other type:(enum ColorDifferenceType)type SWIFT_WARN_UNUSED_RESULT;
@end


/// Class describing colorimetry data
SWIFT_CLASS("_TtC15NixUniversalSDK9ColorData")
@interface ColorData : NSObject <IColorData>
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
@property (nonatomic, readonly) enum ReferenceWhite reference;
@property (nonatomic, readonly) enum ScanMode mode;
@property (nonatomic, readonly) enum ColorType type;
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull rgbValue;
- (id <IColorData> _Nonnull)convertToType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
- (double)compareToOther:(id <IColorData> _Nonnull)other type:(enum ColorDifferenceType)type SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum describing the available color difference (delta E) equations.
typedef SWIFT_ENUM(NSInteger, ColorDifferenceType, open) {
/// Color difference using CIE1976 equation.
  ColorDifferenceTypeCIE76 = 0,
/// Color difference using CIE1994 equation using constants recommended for graphic design.
  ColorDifferenceTypeCIE94G = 1,
/// Color difference using CIE1994 equation using constants recommended for textiles.
  ColorDifferenceTypeCIE94T = 2,
/// Color difference using CIE2000 equation using default constants.
  ColorDifferenceTypeCIE2000 = 3,
/// Color difference using CMC(l:c) equation with l = 1, and c = 1 (‘threshold of imperceptibility’)
  ColorDifferenceTypeCMC1_1 = 4,
/// Color difference using CMC(l:c) equation with l = 2, and c = 1 (‘threshold of acceptability’)
  ColorDifferenceTypeCMC2_1 = 5,
};

/// Enum to describe the base color data types available for <code>IColorData</code> objects. Values for each of these types can be freely converted to each other without loss of color data.
typedef SWIFT_ENUM(NSInteger, ColorType, open) {
/// Report color value as CIEXYZ value on unity scale.
  ColorTypeCIEXYZ = 0,
/// Report color value as CIELAB value.
  ColorTypeCIELAB = 1,
/// Report color value as CIELCH / LCH(ab) value
  ColorTypeCIELCH = 2,
/// Report color as CIELUV value
  ColorTypeCIELUV = 3,
};

enum Illuminant : uint8_t;
enum Observer : uint8_t;
enum DensityStatus : NSInteger;

/// Color math utility functions
SWIFT_CLASS("_TtC15NixUniversalSDK10ColorUtils")
@interface ColorUtils : NSObject
/// Takes CIEXYZ value and its reference white to calculate CIELAB value. <code>xyz</code> and <code>xyzRef</code> can be either unity (0 - 1) or scaled (0 - 100) input, but both vectors must be the same scale; if <code>xyz</code> is unity scale, <code>xyzRef</code> must also be unity scale
/// \param xyz CIEXYZ value (element order X, Y, Z)
///
/// \param xyzRef reference white (element order X, Y, Z)
///
///
/// returns:
/// CIELAB value (element order L, a, b)
+ (NSArray<NSNumber *> * _Nonnull)xyzToLabWithXyz:(NSArray<NSNumber *> * _Nonnull)xyz xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Clips CIEXYZ values in between 0 and the value of the reference white to ensure X,Y,Z are in the proper range.
/// \param xyz CIEXYZ value for color (X, Y, Z)
///
/// \param xyzRef CIEXYZ value for reference white (X, Y, Z)
///
///
/// returns:
/// CIEXYZ value (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)clipXyzWithXyz:(NSArray<NSNumber *> * _Nonnull)xyz xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELAB value and its reference white to calculate CIEXYZ value
/// \param lab CIELAB value (element order L, a, b)
///
/// \param xyzRef Reference white (element order X, Y, Z)
///
///
/// returns:
/// CIEXYZ value (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)labToXyzWithLab:(NSArray<NSNumber *> * _Nonnull)lab xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1976 formula. Both CIELAB values must share the same reference white. If they do not, convert to XYZ, adapt, convert back to CIELAB before calculating dE
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE1976) value
+ (double)deltaE76WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1994 formula. Requires weighting factors kL, k1, and k2 which are dependent on application. Use the <code>deltaE94G</code> method for graphic design applications and the <code>deltaE94T</code> for textile applications. Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
/// \param kL Weighting factor (application dependent)
///
/// \param k1 Weighting factor (application dependent)
///
/// \param k2 Weighting factor (application dependent)
///
///
/// returns:
/// dE (CIE1994) value
+ (double)deltaE94WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 kL:(double)kL k1:(double)k1 k2:(double)k2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1994 formula for the graphic design application (<code>kL</code> = 1, <code>k1</code> = 0.045, <code>k2</code> = 0.015). Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE1994) value
+ (double)deltaE94GWithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE1994 formula for the textiles application (<code>kL</code> = 2, <code>k1</code> = 0.048, <code>k2</code> = 0.014). Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE1994) value
+ (double)deltaE94TWithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE2000 formula using default model parameters (kL = kC = kH = 1.0). Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
///
/// returns:
/// dE (CIE2000) value
+ (double)deltaE00WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CIE2000 formula. Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE.
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
/// \param kL Model parameter (default 1)
///
/// \param kC Model parameter (default 1)
///
/// \param kH Model parameter (default 1)
///
///
/// returns:
/// dE (CIE2000) value
+ (double)deltaE00WithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 kL:(double)kL kC:(double)kC kH:(double)kH SWIFT_WARN_UNUSED_RESULT;
/// Takes two CIELAB values and calculates color difference (dE) using CMC(l:c) formula. Depends on model parameters l and c; common values used are CMC(2:1) for acceptability and CMC(1:1) for perceptibility. Both CIELAB values must share the same reference white. If they do not: convert to XYZ, adapt, convert back to CIELAB before calculating dE
/// \param lab1 First CIELAB value (element order L, a, b)
///
/// \param lab2 Second CIELAB value (element order L, a, b)
///
/// \param l model parameter l
///
/// \param c model parameter c
///
///
/// returns:
/// dE (CMC) value
+ (double)deltaECmcWithLab1:(NSArray<NSNumber *> * _Nonnull)lab1 lab2:(NSArray<NSNumber *> * _Nonnull)lab2 l:(double)l c:(double)c SWIFT_WARN_UNUSED_RESULT;
/// Adapts colour in XYZ from one reference white to another using Bradford adaptation method. NOTE: <code>refIn</code>, <code>refOut</code>, <code>xyzIn</code> must all be on the same scale.
/// \param xyzIn Source color, referenced to <code>refIn</code> (element order X, Y, Z)
///
/// \param refIn Source reference white (element order X, Y, Z)
///
/// \param refOut Destination reference white (element order X, Y, Z)
///
///
/// returns:
/// Adapted color, referenced to <code>refOut</code> (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)adaptXyzWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn refIn:(NSArray<NSNumber *> * _Nonnull)refIn refOut:(NSArray<NSNumber *> * _Nonnull)refOut SWIFT_WARN_UNUSED_RESULT;
/// Calculates linear RGB from XYZ given chromaticity coordinates of RGB working space primaries and reference whites of RGB and XYZ value
/// \param xyzIn Input colour XYZ values, unity scale (element order X, Y, Z)
///
/// \param refIn Reference white of input colour <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
/// \param rChrom RGB space red primary chromaticity coordinates (element order x, y)
///
/// \param gChrom RGB space green primary chromaticity coordinates (element order x, y)
///
/// \param bChrom RGB space blue primary chromaticity coordinates (element order x, y)
///
/// \param wChrom RGB space reference white/grey chromaticity coordinates (element order x, y)
///
///
/// returns:
/// Linear RGB value, unity scale, (element order R, G, B)
+ (NSArray<NSNumber *> * _Nonnull)xyzToRgbWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn refIn:(NSArray<NSNumber *> * _Nonnull)refIn rChrom:(NSArray<NSNumber *> * _Nonnull)rChrom gChrom:(NSArray<NSNumber *> * _Nonnull)gChrom bChrom:(NSArray<NSNumber *> * _Nonnull)bChrom wChrom:(NSArray<NSNumber *> * _Nonnull)wChrom SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ from linear RGB given chromaticity coordinates of RGB working space primaries and reference whites of RGB and XYZ value.
/// \param rgbIn Input linear RGB value, unity scale (element order R, G, B)
///
/// \param rChrom RGB space red primary chromaticity coordinates (element order x, y)
///
/// \param gChrom RGB space green primary chromaticity coordinates (element order x, y)
///
/// \param bChrom RGB space blue primary chromaticity coordinates (element order x, y)
///
/// \param wChrom RGB space reference white/grey chromaticity coordinates (element order x, y)
///
/// \param refOut Selected reference white of output XYZ color, unity scale (element order X, Y, Z)
///
///
/// returns:
/// XYZ value, unity scale, with reference white <code>refOut</code> (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)rgbToXyzWithRgbIn:(NSArray<NSNumber *> * _Nonnull)rgbIn rChrom:(NSArray<NSNumber *> * _Nonnull)rChrom gChrom:(NSArray<NSNumber *> * _Nonnull)gChrom bChrom:(NSArray<NSNumber *> * _Nonnull)bChrom wChrom:(NSArray<NSNumber *> * _Nonnull)wChrom refOut:(NSArray<NSNumber *> * _Nonnull)refOut SWIFT_WARN_UNUSED_RESULT;
/// Calculates companded sRGB value from XYZ given reference white of XYZ value
/// \param xyzIn Input colour XYZ values, unity scale (element order X, Y, Z)
///
/// \param refIn Reference white of input colour <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
///
/// returns:
/// Non-linear sRGB value, 0-255 scale (element order R, G, B)
+ (NSArray<NSNumber *> * _Nonnull)xyzToSrgbWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn refIn:(NSArray<NSNumber *> * _Nonnull)refIn SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ from sRGB value.
/// \param sRgb Non-linear sRGB value, 0-255 scale (element order R, G, B)
///
/// \param refOut Selected reference white of output XYZ color, unity scale (element order X, Y, Z)
///
///
/// returns:
/// XYZ value, unity scale, with reference white <code>refOut</code> (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)sRgbToXyzWithSRgb:(NSArray<NSNumber *> * _Nonnull)sRgb refOut:(NSArray<NSNumber *> * _Nonnull)refOut SWIFT_WARN_UNUSED_RESULT;
/// Takes CIEXYZ value and its reference white to calculate CIELUV value
/// \param xyzIn CIEXYZ value (element order X, Y, Z)
///
/// \param xyzRef CIEXYZ reference white (element order X, Y, Z)
///
///
/// returns:
/// CIELUV value (element order L, u, v)
+ (NSArray<NSNumber *> * _Nonnull)xyzToLuvWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELUV value and its reference white to calculate CIEXYZ value
/// \param luvIn CIELUV value (element order L, u, v)
///
/// \param xyzRef CIEXYZ reference white (element order X, Y, Z)
///
///
/// returns:
/// CIEXYZ value (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)luvToXyzWithLuvIn:(NSArray<NSNumber *> * _Nonnull)luvIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELAB value and converts to polar coordinates (LCH)
/// \param labIn CIELAB value (element order L, a, b)
///
///
/// returns:
/// LCHab value (element order L, c, h). Hue angle h is in degrees
+ (NSArray<NSNumber *> * _Nonnull)labToLchWithLabIn:(NSArray<NSNumber *> * _Nonnull)labIn SWIFT_WARN_UNUSED_RESULT;
/// Takes LCHab value and converts to CIELAB
/// \param lchIn LCHab value (element order L, c, h). Hue angle h is in degrees
///
///
/// returns:
/// CIELAB value (element order L, a, b)
+ (NSArray<NSNumber *> * _Nonnull)lchToLabWithLchIn:(NSArray<NSNumber *> * _Nonnull)lchIn SWIFT_WARN_UNUSED_RESULT;
/// Takes CIELUV value and converts to polar coordinates (LCH)
/// \param luvIn CIELUV value (element order L, u, v)
///
///
/// returns:
/// LCHuv value (element order L, c, h). Hue angle h is in degrees
+ (NSArray<NSNumber *> * _Nonnull)luvToLchWithLuvIn:(NSArray<NSNumber *> * _Nonnull)luvIn SWIFT_WARN_UNUSED_RESULT;
/// Takes LCHuv value and converts to CIELUV
/// \param lchIn LCHuv value (element order L, c, h). Hue angle h is in degrees
///
///
/// returns:
/// CIELUV value (element order L, u, v)
+ (NSArray<NSNumber *> * _Nonnull)lchToLuvWithLchIn:(NSArray<NSNumber *> * _Nonnull)lchIn SWIFT_WARN_UNUSED_RESULT;
/// Takes reflectance data on 10 nm intervals and calculates a CIEXYZ value according to ASTM E308. Data must be provided on 10 nm intervals corresponding to the nearest 10 nanometer. CIEXYZ values are calculated across the range 360 - 780 nm. If the provided data spans a shorter range (eg - 400 - 700 nm), the values at the boundaries are repeated.
/// \param lambda Wavelength values of provided reflectance data.
///
/// \param reflectance Reflectance data. Must contain the same number of elements as <code>lambda</code>
///
/// \param illuminant Selected illuminant
///
/// \param observer Selected observer
///
///
/// returns:
/// CIEXYZ value reported on 0 - 1.0 scale (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)spectral10ToXyzWithLambda:(NSArray<NSNumber *> * _Nonnull)lambda reflectance:(NSArray<NSNumber *> * _Nonnull)reflectance illuminant:(enum Illuminant)illuminant observer:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Takes reflectance data on 10 nm intervals and calculates CMYK densities according to ISO 5-3:2009. Data must be provided on 10 nm intervals corresponding to the nearest 10 nanometer. Density values are calculated across the range 340 - 770 nm. If the provided data spans a shorter range (eg - 400 - 700 nm), the values at the boundaries are repeated.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
/// \param lambda Wavelength values of provided reflectance data.
///
/// \param reflectance Reflectance data. Must contain the same number of elements as <code>lambda</code>
///
/// \param status Selected density status
///
///
/// returns:
/// CMYK densities (element order C, M, Y, K)
+ (NSArray<NSNumber *> * _Nonnull)spectral10ToDensityWithLambda:(NSArray<NSNumber *> * _Nonnull)lambda reflectance:(NSArray<NSNumber *> * _Nonnull)reflectance status:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
/// Calculates CMYK value from XYZ input using built in lookup tables
/// \param xyzIn XYZ colour, unity scale (element order X, Y, Z)
///
/// \param xyzRef Reference white value for <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
///
/// returns:
/// CMYK value on unity scale (element order C, M, Y, K)
+ (NSArray<NSNumber *> * _Nonnull)xyzToCmykWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef bpc:(BOOL)bpc SWIFT_WARN_UNUSED_RESULT;
/// Calculates CMYK value from XYZ using lookup tables provided as <code>inputCurves</code> arguments
/// \param xyzIn XYZ colour, unity scale (element order X, Y, Z)
///
/// \param xyzRef Reference white value for <code>xyzIn</code>, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
/// \param m 3x3 matrix extracted from ICC profile: transformation matrix to perform on LAB value (code only tested with identity matrix)
///
/// \param inputCurves 256x3 matrix extracted from ICC profile: <code>InputCurves</code>
///
/// \param clut Extracted from ICC profile: Lab to CMYK LUT (flattened 33x33x33 array with 4 channels, one each for C,M,Y,K)
///
/// \param outputCurves 256x4 matrix extracted from ICC profile: <code>OutputCurves</code>
///
///
/// returns:
/// CMYK value on unity scale (element order C, M, Y, K)
+ (NSArray<NSNumber *> * _Nonnull)xyzToCmykWithXyzIn:(NSArray<NSNumber *> * _Nonnull)xyzIn xyzRef:(NSArray<NSNumber *> * _Nonnull)xyzRef bpc:(BOOL)bpc m:(NSArray<NSArray<NSNumber *> *> * _Nonnull)m inputCurves:(NSArray<NSArray<NSNumber *> *> * _Nonnull)inputCurves clut:(NSArray<NSArray<NSNumber *> *> * _Nonnull)clut outputCurves:(NSArray<NSArray<NSNumber *> *> * _Nonnull)outputCurves SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ value from CMYK input using built-in lookup tables
/// \param cmykIn CMYK colour input, unity scale (element order C, M, Y, K)
///
/// \param refOut Reference white value for XYZ output, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
///
/// returns:
/// XYZ value output, unity scale (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)cmykToXyzWithCmykIn:(NSArray<NSNumber *> * _Nonnull)cmykIn refOut:(NSArray<NSNumber *> * _Nonnull)refOut bpc:(BOOL)bpc SWIFT_WARN_UNUSED_RESULT;
/// Calculates XYZ value from CMYK input using lookup tables provided as input arguments
/// \param cmykIn CMYK colour input, unity scale (element order C, M, Y, K)
///
/// \param refOut Reference white value for XYZ output, unity scale (element order X, Y, Z)
///
/// \param bpc Black point compensation enabled / disabled
///
/// \param m 3x3 Extracted from ICC profile: transformation matrix to perform on LAB value (NOT used in current function)
///
/// \param input 256x4 matrix extracted from ICC profile: <code>InputCurves</code>
///
/// \param clut 6561x3 matrix extracted from ICC profile: CMYK to LAB LUT (flattened 9x9x9x9 array with 3 channels, one each for L, A, B)
///
/// \param output Extracted from ICC profile: <code>OutputCurves</code> (NOT used in current function, default profile has 1:1 output)
///
///
/// returns:
/// XYZ value output, unity scale (element order X, Y, Z)
+ (NSArray<NSNumber *> * _Nonnull)cmykToXyzWithCmykIn:(NSArray<NSNumber *> * _Nonnull)cmykIn refOut:(NSArray<NSNumber *> * _Nonnull)refOut bpc:(BOOL)bpc m:(NSArray<NSArray<NSNumber *> *> * _Nonnull)m input:(NSArray<NSArray<NSNumber *> *> * _Nonnull)input clut:(NSArray<NSArray<NSNumber *> *> * _Nonnull)clut output:(NSArray<NSArray<NSNumber *> *> * _Nonnull)output SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Enum describing the possible status of commands executed by the Nix device, as provided in the <code>DeviceResultCallback</code>.
typedef SWIFT_ENUM(NSInteger, CommandStatus, open) {
/// Status code indicating that the command completed successfully.
  CommandStatusSUCCESS = 0,
/// Status code indicating that the command was aborted because the Nix device was not ready (i.e. - it was already executing another command).
  CommandStatusERROR_NOT_READY = 1,
/// Status code indicating that the command was aborted because the it was not supported by the Nix device instance.
  CommandStatusERROR_NOT_SUPPORTED = 2,
/// Status code indicating that the command was aborted because it contained invalid arguments.
  CommandStatusERROR_INVALID_ARGUMENT = 3,
/// Status code indicating that the command was aborted because of a low power state on the Nix device (e.g. - insufficient battery power to complete a measurement).
  CommandStatusERROR_LOW_POWER = 4,
/// Status code indicating that the command failed due to a timeout error.
  CommandStatusERROR_TIMEOUT = 5,
/// Status code indicating that the measurement operation failed due to the detection of ambient light leakage.
  CommandStatusERROR_AMBIENT_LIGHT = 6,
/// Status code indicating that the in-field calibration operation failed due to high delta E (i.e. - the calibration reference tile could not be verified by its color value). This status is only possible after a <code>IDeviceCompat/runFieldCalibration(tileString:completion:)</code> command.
  CommandStatusERROR_SCAN_DELTA = 7,
/// Status code indicating that the command failed due to an unknown / internal SDK error.
  CommandStatusERROR_INTERNAL = 8,
/// Status code indicating that the in-field calibration operation completed successfully, but a temperature warning was issued (i.e. - the ambient temperature of the device is currently outside of the recommended range). This status is only possible after a <code>IDeviceCompat/runFieldCalibration(tileString:completion:)</code> command.
  CommandStatusWARNING_TEMPERATURE = 9,
/// Status code indicating that the command failed due to a problem with the <code>LicenseManager</code>. Check <code>LicenseManager/state</code> for details.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
  CommandStatusERROR_LICENSE = 10,
};

@class NSString;

/// Protocol describing density data
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
SWIFT_PROTOCOL("_TtP15NixUniversalSDK12IDensityData_")
@protocol IDensityData
/// Density values (4 channels, CMYK order)
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
/// Indicates which channel (0 - 3) in <code>value</code> has the strongest response, with greyness override
@property (nonatomic, readonly) NSInteger autoIndex;
/// Density status for this value
@property (nonatomic, readonly) enum DensityStatus status;
/// Density status label for this value (eg - ‘T’ for <code>DensityStatus/T</code>)
@property (nonatomic, readonly, copy) NSString * _Nonnull statusLabel;
/// Scan mode for this measurement.
@property (nonatomic, readonly) enum ScanMode mode;
@end


/// Class describing density data
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15NixUniversalSDK11DensityData")
@interface DensityData : NSObject <IDensityData>
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
@property (nonatomic, readonly) NSInteger autoIndex;
@property (nonatomic, readonly) enum DensityStatus status;
@property (nonatomic, readonly, copy) NSString * _Nonnull statusLabel;
@property (nonatomic, readonly) enum ScanMode mode;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum to describe the available options for density status
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, DensityStatus, open) {
/// Status A (ISO 5-3:2009)
  DensityStatusA = 1,
/// Status E (ISO 5-3:2009)
  DensityStatusE = 2,
/// Status I (ISO 5-3:2009)
  DensityStatusI = 3,
/// Status T (ISO 5-3:2009)
  DensityStatusT = 4,
/// Unknown / undefined conditions
  DensityStatusNONE = 0,
};

enum DeviceScannerState : NSInteger;
@protocol IDeviceCompat;

/// Protocol implemented by the <code>DeviceScanner</code>
SWIFT_PROTOCOL("_TtP15NixUniversalSDK14IDeviceScanner_")
@protocol IDeviceScanner
/// Current state of the <code>IDeviceScanner</code>
@property (nonatomic, readonly) enum DeviceScannerState state;
/// Starts a search for nearby Nix devices using Bluetooth for time interval of <code>DeviceScanner/DEFAULT_GENERAL_SCAN_PERIOD_MS</code>.
/// <ul>
///   <li>
///     See also: <code>start(scanPeriodMs:closure:)</code>
///   </li>
/// </ul>
/// \param closure Closure invoked when a device is found. Invoked with a <code>nil</code> result when a search times out and device was not found.
///
- (enum DeviceScannerState)startWithClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Starts a search for nearby Nix devices using Bluetooth for a selected time interval. If no timeout interval is specified, the search will run for <code>DeviceScanner/DEFAULT_GENERAL_SCAN_PERIOD_MS</code>.
/// <ul>
///   <li>
///     See also: <code>start(closure:)</code>
///   </li>
/// </ul>
/// \param scanPeriodMs Period to run the search in milliseconds.
///
/// \param closure Closure invoked when a device is found. Invoked with a <code>nil</code> result when a search times out and device was not found.
///
- (enum DeviceScannerState)startForPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Starts a search for a specific Nix device using Bluetooth. The search will run until the specified device is found, or until <code>DeviceScanner/DEFAULT_SINGLE_DEVICE_PERIOD_MS</code> elapses, whichever is shorter. Invoked with a <code>nil</code> result when a search times out and device was not found.
/// <ul>
///   <li>
///     See also: <code>startSearchForId(_:scanPeriodMs:closure:)</code>
///   </li>
/// </ul>
/// \param id Nix device ID used to filter search results
///
/// \param closure Closure invoked when a device is found.
///
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Starts a search for a specific Nix device using Bluetooth. The search will run until the specified device is found, or until a timeout elapses, whichever is shorter. If no timeout interval is specified, the search will run for <code>DeviceScanner/DEFAULT_SINGLE_DEVICE_PERIOD_MS</code>.
/// <ul>
///   <li>
///     See also: <code>startSearchForId(_:closure:)</code>
///   </li>
/// </ul>
/// \param id Nix device ID used to filter search results
///
/// \param scanPeriodMs Max time period to run the search, in milliseconds
///
/// \param closure Closure invoked when a device is found. Invoked with a <code>nil</code> result when a search times out and device was not found.
///
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id forPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
/// Stops a Bluetooth search if one is currently running.
- (void)stop;
@end

@protocol ScannerStateDelegate;

/// Class used to discover nearby Nix devices
SWIFT_CLASS("_TtC15NixUniversalSDK13DeviceScanner")
@interface DeviceScanner : NSObject <IDeviceScanner>
- (nonnull instancetype)initWithDelegate:(id <ScannerStateDelegate> _Nonnull)delegate OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) enum DeviceScannerState state;
- (enum DeviceScannerState)startWithClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (enum DeviceScannerState)startForPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (enum DeviceScannerState)startSearchForId:(NSString * _Nonnull)id forPeriodMs:(NSInteger)scanPeriodMs withClosure:(void (^ _Nonnull)(id <IDeviceCompat> _Nullable))closure SWIFT_WARN_UNUSED_RESULT;
- (void)stop;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum describing the possible states of the <code>IDeviceScanner</code>
typedef SWIFT_ENUM(NSInteger, DeviceScannerState, open) {
/// Bluetooth scanner is not actively searching for devices.
  DeviceScannerStateIDLE = 0,
/// Bluetooth scanner is actively searching for devices.
  DeviceScannerStateSCANNING = 1,
/// Bluetooth scanner could not start because Bluetooth permissions have not been granted.
  DeviceScannerStateERROR_BLUETOOTH_PERMISSIONS = 2,
/// Bluetooth scanner could not start because Bluetooth is disabled on this mobile device.
  DeviceScannerStateERROR_BLUETOOTH_DISABLED = 3,
/// Bluetooth scanner could not start because Bluetooth is not available on this mobile device.
  DeviceScannerStateERROR_BLUETOOTH_UNAVAILABLE = 4,
/// Bluetooth scanner could not start because an invalid hardware ID was provided.
  DeviceScannerStateERROR_INVALID_HARDWARE_ID = 5,
/// Bluetooth scanner could not start due to an internal error.
  DeviceScannerStateERROR_INTERNAL = 6,
/// Bluetooth scanner could not start due to a problem with the <code>LicenseManager</code>. Check <code>LicenseManager/state</code> for details.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
  DeviceScannerStateERROR_LICENSE = 7,
/// Bluetooth scanner state is cold / unknown (scanner is initializing)
  DeviceScannerStateCOLD = -1,
};

/// Enum describing the possible states of the <code>IDeviceCompat</code>
typedef SWIFT_ENUM(NSInteger, DeviceState, open) {
/// The device is disconnected.
  DeviceStateDISCONNECTED = 0,
/// The device is busy establishing a connection with the host device.
  DeviceStateBUSY_CONNECTING = 1,
/// The device is busy; a connection has been opened but services are being discovered.
  DeviceStateBUSY_DISCOVERING = 2,
/// The device is busy; a connection has been opened but characteristic notification / subscriptions are pending.
  DeviceStateBUSY_SUBSCRIBING = 3,
/// The device is busy with a data transfer to the host device.
  DeviceStateBUSY_DATA_TRANSFER = 4,
/// The device is busy executing a command.
  DeviceStateBUSY_RUNNING_COMMAND = 5,
/// The device is idle and ready to receive commands. This is the only state where commands can be successfully executed.
  DeviceStateIDLE = 6,
};

enum DeviceStatus : NSInteger;
@class NSNumber;

/// Definition for a callback from an <code>IDeviceCompat</code> instance on a connection state change, battery state change, or external power state change.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK19DeviceStateDelegate_")
@protocol DeviceStateDelegate
/// Called when the Nix device has completed the connection process and is now idle.
/// \param sender Device instance that invoked this call
///
- (void)onConnected:(id <IDeviceCompat> _Nonnull)sender;
/// Called when the Nix device has disconnected from the host.
/// \param sender Device instance that invoked this call
///
/// \param status Status code indicating the reason for the disconnection
///
- (void)onDisconnected:(id <IDeviceCompat> _Nonnull)sender status:(enum DeviceStatus)status;
/// Called when the Nix device has updated its battery level measurement.
/// \param sender Device instance that has invoked this call
///
/// \param newState New battery level (0 to 100)
///
- (void)onBatteryStateChanged:(id <IDeviceCompat> _Nonnull)sender newState:(NSNumber * _Nonnull)newState;
/// Called when the Nix device has been connected or disconnected from an external power source.
/// \param sender Device instance that has invoked this call
///
/// \param newState New external power connection state
///
- (void)onExtPowerStateChanged:(id <IDeviceCompat> _Nonnull)sender newState:(BOOL)newState;
@end

/// Enum describing the possible causes of a device disconnection event in the <code>DeviceStateDelegate</code>.
typedef SWIFT_ENUM(NSInteger, DeviceStatus, open) {
/// The device has disconnected normally (e.g. - via calling <code>IDeviceCompat/disconnect()</code>).
  DeviceStatusSUCCESS = 0,
/// The device connection attempt was cancelled because the maximum number of attempts was reached.
  DeviceStatusERROR_MAX_ATTEMPTS = 1,
/// The device connection attempt was cancelled due to a timeout error.
  DeviceStatusERROR_TIMEOUT = 2,
/// The device connection attempt was cancelled because the specified device type was not supported.
  DeviceStatusERROR_UNSUPPORTED_DEVICE = 3,
/// The device has disconnected unexpectedly (possibly due to low Bluetooth signal strength or low battery level).
  DeviceStatusERROR_DROPPED_CONNECTION = 4,
/// The device connection attempt was cancelled because the specified device was not authorized for this build of the Nix SDK. Check that the device allocation code and/or serial number is expected to be authorized for this build.
  DeviceStatusERROR_UNAUTHORIZED = 5,
/// The device has disconnected for an unknown reason (internal SDK error).
  DeviceStatusERROR_INTERNAL = 6,
/// The device disconnected due to a problem with the <code>LicenseManager</code>. Check that the license is active via <code>LicenseManager/state</code> and that the device type is supported via <code>LicenseManager/isDeviceTypeSupported(_:)</code>.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
  DeviceStatusERROR_LICENSE = 7,
};

/// Enum to describe the supported Nix device types
typedef SWIFT_ENUM(uint8_t, DeviceType, open) {
/// Type for Nix Mini colorimeter
  DeviceTypeMINI = 0x00,
/// Type for Nix Mini 2 colorimeter
  DeviceTypeMINI2 = 0x01,
/// Type for Nix Pro colorimeter
  DeviceTypePRO = 0x02,
/// Type for Nix Pro 2 colorimeter
  DeviceTypePRO2 = 0x03,
/// Type for Nix QC colorimeter
  DeviceTypeQC = 0x04,
/// Type for Nix Spectro 2 spectrophotometer
  DeviceTypeSPECTRO2 = 0x05,
/// Type for Nix Mini 3 colorimeter
  DeviceTypeMINI3 = 0x06,
/// Type for Nix Spectro L spectrophometer
/// <ul>
///   <li>
///     Since 4.1.0
///   </li>
/// </ul>
  DeviceTypeSPECTROL = 0x07,
/// Unknown / other device type
  DeviceTypeUNKNOWN = 0xFF,
};


/// Class to describe Nix device revisions
SWIFT_CLASS("_TtC15NixUniversalSDK13DeviceVersion")
@interface DeviceVersion : NSObject
/// String value for this version
@property (nonatomic, readonly, copy) NSString * _Nonnull string;
/// Single character prefix for this version. Expected values are ‘F’ for  firmware version, ‘H’ for hardware version, ‘S’ for software version.
@property (nonatomic, readonly, copy) NSString * _Nonnull prefix;
/// Major revision number
@property (nonatomic, readonly) NSInteger major;
/// Minor revision number
@property (nonatomic, readonly) NSInteger minor;
/// Patch revision number
@property (nonatomic, readonly) NSInteger patch;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



enum InterfaceType : NSInteger;
@class NSDate;
@protocol IMeasurementData;

/// Protocol describing the supported properties and methods for a Nix device. <code>IDeviceCompat</code> objects are found nearby using the <code>DeviceScanner</code>.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK13IDeviceCompat_")
@protocol IDeviceCompat
/// Unique identifier for this device
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// Signal strength for this device
@property (nonatomic) NSInteger rssi;
/// Current state of this device
@property (nonatomic, readonly) enum DeviceState state;
/// Type for this device
@property (nonatomic, readonly) enum DeviceType type;
/// Interface / connection type for this device
@property (nonatomic, readonly) enum InterfaceType interfaceType;
/// Name for this device
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// Factory note for this device, containing allocation code. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, copy) NSString * _Nonnull note;
/// Serial number for this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, copy) NSString * _Nonnull serialNumber;
/// Firmware version of this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) DeviceVersion * _Nonnull firmwareVersion;
/// Hardware version of this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) DeviceVersion * _Nonnull hardwareVersion;
/// Software version of this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) DeviceVersion * _Nonnull softwareVersion;
/// Current battery level for this device (0 - 100), or <code>nil</code> if not available. <code>NSNumber</code> contains an integer value. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) NSNumber * _Nullable batteryLevel;
/// Flag: <code>true</code> if sufficient power is available to complete a measurement, <code>false</code> if a measurement will be aborted (function of external power connection and battery level)
@property (nonatomic, readonly) BOOL powerState;
/// External power connection state for this device. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly) BOOL extPowerState;
/// Last known temperature of the device, corresponding to the most recently completed scan since the device was connected. <code>NSNumber</code> contains a <code>Float</code> value. Value is <code>nil</code> if the device does not support this feature. This value is only valid if the device is connected and a measurement has completed.
@property (nonatomic, readonly, strong) NSNumber * _Nullable scanTemperature;
/// Baseline temperature for this device. Corresponds to in-field normalization temperature for <code>DeviceType/SPECTRO2</code> and <code>DeviceType/MINI3</code>, or factory temperature for others. <code>NSNumber</code> contains a <code>Float</code> value. Value is <code>nil</code> if the device does not support this feature. The value is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, strong) NSNumber * _Nullable referenceTemperature;
/// Date that the last in-field normalization was last performed, or <code>nil</code> if this device does not support this feature.
@property (nonatomic, readonly, copy) NSDate * _Nullable referenceDate;
/// Lifetime scan count for this device, or <code>nil</code> if this device does not support this feature. <code>NSNumber</code> contains an <code>Int</code> value.
@property (nonatomic, readonly, strong) NSNumber * _Nullable scanCount;
/// UUID for this <code>NixUniversalSDK</code> license
/// <ul>
///   <li>
///     See also <code>LicenseManager/uuid</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nonnull sdkId;
/// Open a connection to this Nix device. This operation is asynchronous and this method returns immediately. Status of this operation is updated via the provided <code>DeviceStateDelegate</code> callback.
/// \param delegate Delegate through which device state changes are provided.
///
- (void)connect:(id <DeviceStateDelegate> _Nonnull)delegate;
/// Disconnect from this Nix device, or cancel a connection attempt currently in progress.
- (void)disconnect;
/// Manually run a LED test routine. On devices featuring RGB feedback, this will use the RGB LEDs. On other devices, this will flash the white LEDs. This method is asynchronous and will return immediately.
/// \param completion Closure which will provide command status on completion.
///
- (void)ledTest:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Run a measurement for all supported scan modes. This method is asynchronous and will return immediately.
/// <ul>
///   <li>
///     See also: <code>measure(modes:completion:)-18cni</code>
///   </li>
///   <li>
///     See also (Swift only): <code>measure(modes:completion:)-71wc2</code>
///   </li>
/// </ul>
/// \param completion Closure which will provide command status on completion.
///
- (void)measure:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Run a measurement in the specified scan modes. If any unsupported modes are selected, the measurement will fail with status code <code>CommandStatus/ERROR_NOT_SUPPORTED</code>. This method is asynchronous and will return immediately.
/// <ul>
///   <li>
///     See also: <code>measure(completion:)</code>
///   </li>
/// </ul>
/// \param modes Scan modes to select. Set must contain <code>NSNumber</code> values matching <code>ScanMode</code> enum values
///
/// \param completion Closure which will provide command status on completion.
///
- (void)measureWithModes:(NSSet<NSNumber *> * _Nonnull)modes completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Start field calibration using provided reference tile, if supported. Upon executing this command, the scan of the reference tile will begin immediately. The user MUST be prompted to place the device onto the reference tile BEFORE this method is executed. This method is asynchronous and will return immediately.
/// This command requires data from the reference tile QR code. As the format varies between different device types, the string data should be provided exactly as decoded from the QR code.
/// \param tileString String value decoded from the reference tile QR code.
///
/// \param completion Closure which will provide command status on completion.
///
- (void)runFieldCalibration:(NSString * _Nonnull)tileString completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Invalidates current field calibration date, so that <code>fieldCalibrationDue</code> is reported as <code>true</code>, if supported by the device.
/// \param completion Closure which will provide command status on completion.
///
- (void)invalidateFieldCalibrationWithCompletion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Check if the formatting of the reference tile string data matches the expected format for this device, or <code>false</code> if the device does not support this feature.
/// \param tileString String value decoded from the reference tile QR code.
///
- (BOOL)isTileStringValid:(NSString * _Nonnull)tileString SWIFT_WARN_UNUSED_RESULT;
/// List of scan modes that are supported by this device (set of <code>NSNumber</code> containing <code>ScanMode</code> values). The list is valid only after a connection has successfully been opened.
@property (nonatomic, readonly, copy) NSSet<NSNumber *> * _Nonnull supportedModes;
/// Helper to check if a particular scan mode is supported by this device (i.e. - checks if the mode is present in the <code>supportedModes</code> list). This value is valid only after a connection has successfully been opened.
- (BOOL)isModeSupported:(enum ScanMode)scanMode SWIFT_WARN_UNUSED_RESULT;
/// Flag to indicate if this device type provides spectral information in its supplied <code>IMeasurementData</code> results.
@property (nonatomic, readonly) BOOL providesSpectral;
/// Flag to indicate if this device type provides density information in its supplied <code>IMeasurementData</code> results.
@property (nonatomic, readonly) BOOL providesDensity;
/// List of supported reference white points for the colorimetry data available from the <code>IMeasurementData</code> results provided by this device (set of <code>NSNumber</code> containing <code>ReferenceWhite</code> values)
@property (nonatomic, readonly, copy) NSSet<NSNumber *> * _Nonnull supportedReferences;
/// Helper to check if a particular reference white point is supported by the colorimetry data from this device (i.e - checks if the reference is present in the <code>supportedReferences</code> list`).
- (BOOL)providesColorWithReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Helper to check if a particular reference white point is supported by the colorimetry data from this device (i.e - checks if the reference is present in the <code>supportedReferences</code> list`).
- (BOOL)providesColorForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Helper function to describe if any on-device options are available. Value is <code>true</code> if any one of <code>supportsFieldCalibration</code>, <code>supportsTemperatureCompensation</code>, <code>supportsHapticFeedback</code>, or <code>supportsRgbFeedback</code> is <code>true</code>.
@property (nonatomic, readonly) BOOL hasOptions;
/// Flag to indicate if this device supports in-field calibration using the provided reference tile.
@property (nonatomic, readonly) BOOL supportsFieldCalibration;
/// Flag to indicate if in-field calibration is recommended for this device at this time (if supported). This value is only valid after opening a connection and is a function of both time and ambient temperature. This value also updates each time a measurement is completed.
@property (nonatomic, readonly) BOOL fieldCalibrationDue;
/// Maximum Delta E threshold used when performing in-field calibration (if supported), or NaN if the device does not support this operation. If a difference from the reference greater than this value is detected during <code>runFieldCalibration(tileString:completion:)</code>, the command will fail with status <code>CommandStatus/ERROR_SCAN_DELTA</code>.
@property (nonatomic) double fieldCalibrationMaxDelta;
/// Flag to indicate if in-field calibration results are applied (<code>true</code>) or bypassed (<code>false</code>) when evaluating the final calibrated measurement result. Value is <code>true</code> by default if supported by the device. It is recommended to leave this set to <code>true</code> if supported.
@property (nonatomic, readonly) BOOL fieldCalibrationEnabled;
/// Set the value for <code>fieldCalibrationEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setFieldCalibrationEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Flag to indicate if this device supports automatic temperature compensation to correct for small changes in ambient temperature.
@property (nonatomic, readonly) BOOL supportsTemperatureCompensation;
/// Flag to indicate if ambient temperature compensation / correction is applied (<code>true</code>) or bypassed (<code>false</code>) when evaluating the final calibrated measurement. Value is <code>true</code> by default if supported by the device. It is recommended to leave this set to <code>true</code> if supported.
@property (nonatomic, readonly) BOOL temperatureCompensationEnabled;
/// Set the value for <code>temperatureCompensationEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setTemperatureCompensationEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Flag to indicate if the device supports built-in haptic feedback.
@property (nonatomic, readonly) BOOL supportsHapticFeedback;
/// Flag to indicate if device haptic feedback is enabled.
@property (nonatomic, readonly) BOOL hapticFeedbackEnabled;
/// Set the value for <code>hapticFeedbackEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setHapticFeedbackEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
/// Flag to indicate if the device supports built-in RGB feedback.
@property (nonatomic, readonly) BOOL supportsRgbFeedback;
/// Flag to indicate if device RGB feedback is enabled.
@property (nonatomic, readonly) BOOL rgbFeedbackEnabled;
/// Set the value for <code>rgbFeedbackEnabled</code>. This method is asynchronous and will return immediately.
/// \param enabled New state for this option
///
/// \param completion Closure which will provide command status on completion.
///
- (void)setRgbFeedbackEnabled:(BOOL)enabled completion:(void (^ _Nonnull)(enum CommandStatus, NSDictionary<NSNumber *, id <IMeasurementData>> * _Nullable))completion;
@end


@protocol ISpectralData;

/// Protocol defining the properties and methods provided by Nix device measurements. These objects are provided in the <code>DeviceResultCallback</code> callback after a measurement is taken using an <code>IDeviceCompat</code> instance, or can be reconstructed from raw string data using <code>MeasurementData/fromRaw(_:)</code>.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK16IMeasurementData_")
@protocol IMeasurementData
/// Raw data for a measurement. Can be used for measurement object reconstruction.
@property (nonatomic, readonly, copy) NSString * _Nonnull raw;
/// Scan status byte. A value of <code>0x01</code> indicates success, all other values indicate error states. <code>UInt8</code> value wrapped in <code>NSNumber</code>
@property (nonatomic, readonly, strong) NSNumber * _Nonnull status;
/// Device type that was used to make this measurement.
@property (nonatomic, readonly) enum DeviceType deviceType;
/// Scan mode for this measurement.
@property (nonatomic, readonly) enum ScanMode mode;
/// Baseline reference temperature for this measurement, or <code>nil</code> if the device did not support temperature measurements. Optional <code>Float</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tRef;
/// Temperature of the Nix device at the time of this measurement, or <code>nil</code> if the device did not support temperature measurements. Optional <code>Float</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tScan;
/// Flag indicating if temperature compensation was applied to the calibrated output for this measurement. Value is <code>nil</code> if the device did not support temperature measurements. Optional <code>Bool</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tCompEnabled;
/// Flag describing the units for the reported temperature measurement. When <code>true</code>, temperature values are ‘real’ (floating point, degrees C). When <code>false</code>, temperatures are reported on an arbitrary raw scale. Value is <code>nil</code> if the device did not support temperature measurements. Optional <code>Bool</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tReal;
/// Flag indicating if in-field profiling corrections / white reference tile measurements were applied to the calibrated output data. Value is <code>nil</code> if the device did not support in-field profiling. Optional <code>Bool</code> value wrapped in a <code>NSNumber</code>.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tileEnabled;
/// Delta E value between this measurement and factory reference. Value is non-nil for measurement values from <code>IDeviceCompat/runFieldCalibration(tileString:completion:)</code> and <code>nil</code> in all other cases.
@property (nonatomic, readonly, strong) NSNumber * _Nullable tileDelta;
/// Flag (as a <code>NSNumber</code> wrapped <code>Bool</code>) indicating if this measurement provides spectral values. This value depends on both the <code>deviceType</code> and availability of the <code>LicenseFeature/SPECTRAL_DATA</code> feature.
/// <ul>
///   <li>
///     See also: <code>DeviceType/isFeatureSupported(_:)</code>
///   </li>
///   <li>
///     See also: <code>LicenseManager/isFeatureEnabled(_:)</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, strong) NSNumber * _Nonnull providesSpectral;
/// Provides a spectral data object from this measurement, or <code>nil</code> if spectral data is not supported.
@property (nonatomic, readonly, strong) id <ISpectralData> _Nullable spectralData;
/// Flag (as a <code>NSNumber</code> wrapped <code>Bool</code>) indicating if this measurement provides density values. This value depends on both the <code>deviceType</code> and availability of the <code>LicenseFeature/DENSITY_DATA</code> feature.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
@property (nonatomic, readonly, strong) NSNumber * _Nonnull providesDensity;
/// Provides absolute density values for this measurement evaluated as per ISO 5-3:2009, or <code>nil</code> if density data is not supported.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
/// \param status Density status (defaults to <code>DensityStatus/T</code>)
///
- (id <IDensityData> _Nullable)toDensityDataForStatus:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
/// Array describing all reference white points that are available when requesting color data from this measurement using <code>toColorData(reference:type:)</code>.
@property (nonatomic, readonly, copy) NSSet<NSNumber *> * _Nonnull supportedReferences;
/// Returns <code>true</code> if color data for the selected combination of illuminant and observer are available for this measurement.
- (BOOL)providesColorForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if color data for the selected combination of illuminant and observer are available for this measurement.
- (BOOL)providesColorForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if color data for the selected combination of illuminant and observer are available for this measurement.
- (BOOL)providedColorForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Use providesColor(illuminant:observer:) instead");
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toColorData(illuminant:observer:type:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForReference:(enum ReferenceWhite)reference andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toColorData(reference:type:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also <code>toRgbValue(illuminant:observer:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also <code>toRgbValue(reference:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
@end


/// Protocol describing spectral data obtained from a measurement
SWIFT_PROTOCOL("_TtP15NixUniversalSDK13ISpectralData_")
@protocol ISpectralData
/// Wavelength values. Each entry <code>i</code> in this array corresponds to a spectral value in <code>value</code> at the same index.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull lambda;
/// Wavelength spacing (eg - 10 nm)
@property (nonatomic, readonly) NSInteger interval;
/// Spectral reflectance values. Each entry <code>i</code> in this array corresponds to a wavelength value in <code>lambda</code> at the same index.
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
/// Scan mode for this measurement.
@property (nonatomic, readonly) enum ScanMode mode;
/// Provides absolute density values for this measurement for the specified density status evaluated as per ISO 5-3:2009.
/// <ul>
///   <li>
///     Since 4.0.2
///   </li>
/// </ul>
/// \param status Density status (defaults to <code>DensityStatus/T</code>)
///
- (id <IDensityData> _Nullable)toDensityDataForStatus:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if an invalid white point is specified.
/// <ul>
///   <li>
///     See also: <code>toColorData(illuminant:observer:type:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForReference:(enum ReferenceWhite)reference andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides color data from this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if an invalid white point is specified.
/// <ul>
///   <li>
///     See also: <code>toColorData(reference:type:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
/// \param type Output color type (defaults to <code>ColorType/CIEXYZ</code>)
///
- (id <IColorData> _Nullable)toColorDataForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toRgbValue(illuminant:observer:)</code>
///   </li>
/// </ul>
/// \param reference Selected reference white (defaults to <code>ReferenceWhite/D50_2</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
/// Provides an sRGB value for this measurement for the specified illuminant and observer white point. Result is <code>nil</code> if the specified white point is not available for this measurement.
/// <ul>
///   <li>
///     See also: <code>toRgbValue(reference:)</code>
///   </li>
/// </ul>
/// \param illuminant Selected illuminant reference for output (defaults to <code>Illuminant/D50</code>)
///
/// \param observer Selected observer reference for output (defaults to <code>Observer/CIE1931</code>)
///
- (NSArray<NSNumber *> * _Nullable)toRgbValueForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
/// Provides an interpolated reflectance value at a specified wavelength value using natural cubic spines. The cubic splines are evaluated at the points specified by <code>lambda</code> and <code>value</code>. Interpolated values are evaluated using natural cubic splines.
/// \param lT Wavelength (nm) at which to query the interpolated reflectance
///
///
/// returns:
/// interpolated reflectance value at lT
- (float)interpolateAtLt:(float)lT SWIFT_WARN_UNUSED_RESULT;
@end

/// Enum to describe the available options for reference illuminant
typedef SWIFT_ENUM(uint8_t, Illuminant, open) {
  IlluminantA = 0x01,
  IlluminantC = 0x02,
  IlluminantD50 = 0x03,
  IlluminantD55 = 0x04,
  IlluminantD65 = 0x05,
  IlluminantD75 = 0x06,
  IlluminantF2 = 0x07,
  IlluminantF7 = 0x08,
  IlluminantF11 = 0x09,
  IlluminantNONE = 0x00,
};

/// Enum describing the supported connection interface types for Nix devices.
typedef SWIFT_ENUM(NSInteger, InterfaceType, open) {
/// Device does not have a defined connection type.
  InterfaceTypeUNDEFINED = 0,
/// Device connects via Bluetooth (BLE) interface.
  InterfaceTypeBLE = 1,
/// Device connects via USB interface.
  InterfaceTypeUSB_CDC = 2,
};

/// Enum describing the optional features that can be enabled by the <code>LicenseManager</code>. Feature availability can be queried using <code>LicenseManager/isFeatureEnabled(_:)</code>.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, LicenseFeature, open) {
/// Provides access to basic device information and colorimetry values via <code>IColorData</code> for all Nix devices.
  LicenseFeatureBASIC_DATA = 0,
/// Provides access to density values via <code>IDensityData</code>, if supported by the Nix device.
  LicenseFeatureDENSITY_DATA = 1,
/// Provides access to spectral values via <code>ISpectralData</code>, if supported by the Nix device.
  LicenseFeatureSPECTRAL_DATA = 2,
};

enum LicenseManagerState : NSInteger;

/// Class used to manage the license for the Nix Universal SDK. Members of this class are not instantiated or accessed directly. Access to a single shared instance is provided via static methods and properties.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15NixUniversalSDK14LicenseManager")
@interface LicenseManager : NSObject
/// Describes the current state of the  <code>LicenseManager</code>. Nix Universal SDK functions are available only if license is active (i.e. - the state is <code>LicenseManagerState/ACTIVE</code>)
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) enum LicenseManagerState state;)
+ (enum LicenseManagerState)state SWIFT_WARN_UNUSED_RESULT;
/// List of Nix device allocation codes associated with the current license.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSArray<NSString *> * _Nonnull allocations;)
+ (NSArray<NSString *> * _Nonnull)allocations SWIFT_WARN_UNUSED_RESULT;
/// Set of <code>NSNumber</code> containing the <code>DeviceType</code> values enabled by the current license.
/// <ul>
///   <li>
///     See also <code>allowedDeviceTypes-4f98s</code> for convenience in Swift
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<NSNumber *> * _Nonnull allowedDeviceTypes;)
+ (NSSet<NSNumber *> * _Nonnull)allowedDeviceTypes SWIFT_WARN_UNUSED_RESULT;
/// Expiry date for the current license.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSDate * _Nonnull expiry;)
+ (NSDate * _Nonnull)expiry SWIFT_WARN_UNUSED_RESULT;
/// Set of <code>NSNumber</code> containing the <code>LicenseFeature</code> values enabled by the current license.
/// <ul>
///   <li>
///     See also: <code>features-3nk3h</code> for convenience in Swift
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSSet<NSNumber *> * _Nonnull features;)
+ (NSSet<NSNumber *> * _Nonnull)features SWIFT_WARN_UNUSED_RESULT;
/// Vendor identifier for the current license.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull uuid;)
+ (NSString * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
/// Current version of the Nix Universal SDK.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull libraryVersion;)
+ (NSString * _Nonnull)libraryVersion SWIFT_WARN_UNUSED_RESULT;
/// Helper to check if a particular <code>DeviceType</code> is supported by the current license.
+ (BOOL)isDeviceTypeSupported:(enum DeviceType)type SWIFT_WARN_UNUSED_RESULT;
/// Helper to check if a particular <code>LicenseFeature</code> is enabled by the current license.
+ (BOOL)isFeatureEnabled:(enum LicenseFeature)feature SWIFT_WARN_UNUSED_RESULT;
/// Activates a license. The options and signature parameters must exactly match the values provided in the SDK license. Calling this function invalidates any currently active license.
/// \param options License options
///
/// \param signature License signature, used to validate the license options.
///
///
/// returns:
/// License manager state after activation
+ (enum LicenseManagerState)activateWithOptions:(NSString * _Nonnull)options andSignature:(NSString * _Nonnull)signature;
/// Deactivates the current license.
+ (void)deactivate;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum describing the possible states of the <code>LicenseManager</code>.
/// <ul>
///   <li>
///     Since 4.2.0
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, LicenseManagerState, open) {
/// The license has not been activated yet. Activate the license using <code>LicenseManager/activate(options:signature:)</code>.
  LicenseManagerStateINACTIVE = 0,
/// The license has activated successfully and Nix Universal SDK functions are available.
  LicenseManagerStateACTIVE = 1,
/// The license has failed to activate because the signature was invalid. Verify that the correct  options and signature were used when calling <code>LicenseManager/activate(options:signature:)</code>. Contact the Nix SDK support team if this error persists.
  LicenseManagerStateERROR_LICENSE_BAD_SIGNATURE = 2,
/// The license failed to activate because the options string was invalid. Contact the Nix SDK support team.
  LicenseManagerStateERROR_LICENSE_INVALID_OPTIONS = 3,
/// The license has expired and is no longer valid. Contact the Nix SDK support team.
  LicenseManagerStateERROR_LICENSE_EXPIRED = 4,
/// An unknown error occurred when activating the license. Contact the Nix SDK support team.
  LicenseManagerStateERROR_INTERNAL = -1,
};


/// Class describing measurement data from a Nix device
SWIFT_CLASS("_TtC15NixUniversalSDK15MeasurementData")
@interface MeasurementData : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Enum to describe the available options for reference observer
typedef SWIFT_ENUM(uint8_t, Observer, open) {
/// Observer defined by CIE1931 (2 degree)
  ObserverCIE1931 = 0x01,
/// Observer defined by CIE1964 (10 degree)
  ObserverCIE1964 = 0x04,
  ObserverNONE = 0x00,
};

/// Enum to describe valid options for reference white IDs
typedef SWIFT_ENUM(uint16_t, ReferenceWhite, open) {
/// White point using Illuminant A and 2 degree observer.
  ReferenceWhiteA_2 = 0x0000,
/// White point using Illuminant A and 10 degree observer.
  ReferenceWhiteA_10 = 0x0001,
/// White point using Illuminant C and 2 degree observer.
  ReferenceWhiteC_2 = 0x0002,
/// White point using Illuminant C and 10 degree observer.
  ReferenceWhiteC_10 = 0x0003,
/// White point using Illuminant D50 and 2 degree observer.
  ReferenceWhiteD50_2 = 0x0004,
/// White point using Illuminant D50 and 10 degree observer.
  ReferenceWhiteD50_10 = 0x0005,
/// White point using Illuminant D55 and 2 degree observer.
  ReferenceWhiteD55_2 = 0x0006,
/// White point using Illuminant D55 and 10 degree observer.
  ReferenceWhiteD55_10 = 0x0007,
/// White point using Illuminant D65 and 2 degree observer.
  ReferenceWhiteD65_2 = 0x0008,
/// White point using Illuminant D65 and 10 degree observer.
  ReferenceWhiteD65_10 = 0x0009,
/// White point using Illuminant D75 and 2 degree observer.
  ReferenceWhiteD75_2 = 0x000A,
/// White point using Illuminant D75 and 10 degree observer.
  ReferenceWhiteD75_10 = 0x000B,
/// White point using Illuminant F2 and 2 degree observer.
  ReferenceWhiteF2_2 = 0x000C,
/// White point using Illuminant F2 and 10 degree observer.
  ReferenceWhiteF2_10 = 0x000D,
/// White point using Illuminant F7 and 2 degree observer.
  ReferenceWhiteF7_2 = 0x000E,
/// White point using Illuminant F7 and 10 degree observer.
  ReferenceWhiteF7_10 = 0x000F,
/// White point using Illuminant F11 and 2 degree observer.
  ReferenceWhiteF11_2 = 0x0010,
/// White point using Illuminant F11 and 10 degree observer.
  ReferenceWhiteF11_10 = 0x0011,
/// Unknown / other reference white point
  ReferenceWhiteEMPTY = 0xFFFF,
};

/// Enum to describe the measurement modes used by Nix devices
typedef SWIFT_ENUM(uint8_t, ScanMode, open) {
/// M0 conditions (ISO 13655)
  ScanModeM0 = 0x00,
/// M1 conditions (ISO 13655)
  ScanModeM1 = 0x01,
/// M2 conditions (ISO 13655)
  ScanModeM2 = 0x02,
/// Unknown / undefined conditions
  ScanModeNA = 0xFF,
};


/// Protocol definition for a callback to be invoked when an <code>IDeviceScanner</code> starts or stops a search.
SWIFT_PROTOCOL("_TtP15NixUniversalSDK20ScannerStateDelegate_")
@protocol ScannerStateDelegate
/// Called when the <code>IDeviceScanner</code> has initialized. Check <code>state</code> to determine success or failure code.
/// \param sender <code>IDeviceScanner</code> instance that invoked this call
///
/// \param state Current state of the <code>IDeviceScanner</code>
///
- (void)onScannerInit:(id <IDeviceScanner> _Nonnull)sender state:(enum DeviceScannerState)state;
/// Called when an <code>IDeviceScanner</code> has started searching
/// \param sender <code>IDeviceScanner</code> instance that invoked this call
///
- (void)onScannerStarted:(id <IDeviceScanner> _Nonnull)sender;
/// Called when an <code>IDeviceScanner</code> has stopped searching
/// \param sender <code>IDeviceScanner</code> instance that invoked this call
///
- (void)onScannerStopped:(id <IDeviceScanner> _Nonnull)sender;
@end


/// Class describing spectral data
SWIFT_CLASS("_TtC15NixUniversalSDK12SpectralData")
@interface SpectralData : NSObject <ISpectralData>
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull lambda;
@property (nonatomic, readonly) NSInteger interval;
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull value;
@property (nonatomic, readonly) enum ScanMode mode;
- (id <IDensityData> _Nullable)toDensityDataForStatus:(enum DensityStatus)status SWIFT_WARN_UNUSED_RESULT;
- (id <IColorData> _Nullable)toColorDataForReference:(enum ReferenceWhite)reference andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
- (id <IColorData> _Nullable)toColorDataForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer andType:(enum ColorType)type SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nullable)toRgbValueForReference:(enum ReferenceWhite)reference SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSNumber *> * _Nullable)toRgbValueForIlluminant:(enum Illuminant)illuminant andObserver:(enum Observer)observer SWIFT_WARN_UNUSED_RESULT;
- (float)interpolateAtLt:(float)lT SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
